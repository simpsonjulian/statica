{"$schema":"https://json.schemastore.org/sarif-2.1.0.json","version":"2.1.0","runs":[{"tool":{"driver":{"name":"Bearer","rules":[{"id":"javascript_lang_weak_hash_md5","name":"javascript_lang_weak_hash_md5","shortDescription":{"text":"Usage of weak hashing library (MD5)"},"fullDescription":{"text":"Usage of weak hashing library (MD5)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a weak hashing library like MD5 increases the risk of data breaches. MD5 is vulnerable to collision attacks, where two different inputs produce the same output, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use MD5 for hashing or security purposes. It is no longer considered secure for cryptographic applications.\n- **Do** opt for stronger hashing algorithms like SHA-256 for enhanced security.\n  ```javascript\n  const crypto = require(\"crypto\");\n\n  const key = \"secret key\";\n  const hash = crypto.createHmac(\"sha256\", key).update(user.password).digest('hex');\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)","markdown":"## Description\n\nUsing a weak hashing library like MD5 increases the risk of data breaches. MD5 is vulnerable to collision attacks, where two different inputs produce the same output, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use MD5 for hashing or security purposes. It is no longer considered secure for cryptographic applications.\n- **Do** opt for stronger hashing algorithms like SHA-256 for enhanced security.\n  ```javascript\n  const crypto = require(\"crypto\");\n\n  const key = \"secret key\";\n  const hash = crypto.createHmac(\"sha256\", key).update(user.password).digest('hex');\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)"}},{"id":"java_lang_weak_hash_md5","name":"java_lang_weak_hash_md5","shortDescription":{"text":"Usage of weak hashing library (MD5)"},"fullDescription":{"text":"Usage of weak hashing library (MD5)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a weak hashing library like MD5 increases the risk of data breaches. MD5 is vulnerable to collision attacks, where two different inputs produce the same output, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use MD5 for hashing purposes. This algorithm is no longer considered secure and can compromise data integrity.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"MD5\"); // unsafe\n  ```\n- **Do** opt for stronger hashing algorithms like SHA-256 to ensure data security.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)","markdown":"## Description\n\nUsing a weak hashing library like MD5 increases the risk of data breaches. MD5 is vulnerable to collision attacks, where two different inputs produce the same output, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use MD5 for hashing purposes. This algorithm is no longer considered secure and can compromise data integrity.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"MD5\"); // unsafe\n  ```\n- **Do** opt for stronger hashing algorithms like SHA-256 to ensure data security.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)"}},{"id":"javascript_third_parties_new_relic","name":"javascript_third_parties_new_relic","shortDescription":{"text":"Leakage of sensitive data to New Relic"},"fullDescription":{"text":"Leakage of sensitive data to New Relic"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like New Relic is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like New Relic\n\n## References\n- [New Relic Docs](https://docs.newrelic.com/)\n- [Log obfuscation](https://docs.newrelic.com/docs/logs/ui-data/obfuscation-ui/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like New Relic is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like New Relic\n\n## References\n- [New Relic Docs](https://docs.newrelic.com/)\n- [Log obfuscation](https://docs.newrelic.com/docs/logs/ui-data/obfuscation-ui/)\n"}},{"id":"java_lang_http_response_splitting","name":"java_lang_http_response_splitting","shortDescription":{"text":"Unsanitized user input in HTTP response (XSS)"},"fullDescription":{"text":"Unsanitized user input in HTTP response (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncluding unsanitized user input in a HTTP response could allow an attacker inject Carriage Return Line Feed (CRLF) characters into the response. An entirely attacker-controlled response can then be returned, creating a cross-site scripting (XSS) vulnerability.\n\n## Remediations\n\n- **Do not** include user input in cookies or other HTTP headers without proper sanitization. This can prevent attackers from exploiting the input to manipulate the response.\n- **Do** remove CRLF sequences from user input to mitigate the risk of response splitting and XSS attacks. Use the following code snippet as a reference for sanitizing input in Java:\n  ```java\n  var input = request.getParameter(\"data\");\n  var sanitized = input.replaceAll(\"\\r\\n\", \"\");\n  cookie.setValue(sanitized);\n  ```","markdown":"## Description\n\nIncluding unsanitized user input in a HTTP response could allow an attacker inject Carriage Return Line Feed (CRLF) characters into the response. An entirely attacker-controlled response can then be returned, creating a cross-site scripting (XSS) vulnerability.\n\n## Remediations\n\n- **Do not** include user input in cookies or other HTTP headers without proper sanitization. This can prevent attackers from exploiting the input to manipulate the response.\n- **Do** remove CRLF sequences from user input to mitigate the risk of response splitting and XSS attacks. Use the following code snippet as a reference for sanitizing input in Java:\n  ```java\n  var input = request.getParameter(\"data\");\n  var sanitized = input.replaceAll(\"\\r\\n\", \"\");\n  cookie.setValue(sanitized);\n  ```"}},{"id":"java_third_parties_bugsnag","name":"java_third_parties_bugsnag","shortDescription":{"text":"Leakage of sensitive data to Bugsnag"},"fullDescription":{"text":"Leakage of sensitive data to Bugsnag"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Bugsnag is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Bugsnag.\n\n## References\n- [Bugsnag Docs](https://docs.bugsnag.com/platforms/java/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Bugsnag is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Bugsnag.\n\n## References\n- [Bugsnag Docs](https://docs.bugsnag.com/platforms/java/)\n"}},{"id":"java_lang_missing_smtp_ssl_host_check","name":"java_lang_missing_smtp_ssl_host_check","shortDescription":{"text":"Missing SSL host check in SMTP"},"fullDescription":{"text":"Missing SSL host check in SMTP"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nMissing SSL host check in SMTP can compromise the security of email communications. This vulnerability arises when SSL certificates are not properly validated to ensure they originate from the anticipated host, potentially allowing attackers to pose as legitimate entities by leveraging valid SSL certificates from other hosts.\n\n## Remediations\n\n- **Do** configure your email client to verify the server's identity. This step is crucial to prevent attackers from impersonating a trusted server, which could lead to redirection or spoofing attacks.\n  ```java\n  Email email = new Email();\n  email.setSSLOnConnect(true);\n  email.setSSLCheckServerIdentity(true);\n  ```","markdown":"## Description\n\nMissing SSL host check in SMTP can compromise the security of email communications. This vulnerability arises when SSL certificates are not properly validated to ensure they originate from the anticipated host, potentially allowing attackers to pose as legitimate entities by leveraging valid SSL certificates from other hosts.\n\n## Remediations\n\n- **Do** configure your email client to verify the server's identity. This step is crucial to prevent attackers from impersonating a trusted server, which could lead to redirection or spoofing attacks.\n  ```java\n  Email email = new Email();\n  email.setSSLOnConnect(true);\n  email.setSSLCheckServerIdentity(true);\n  ```"}},{"id":"java_third_parties_open_telemetry","name":"java_third_parties_open_telemetry","shortDescription":{"text":"Leakage of sensitive data to OpenTelemetry"},"fullDescription":{"text":"Leakage of sensitive data to OpenTelemetry"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third parties like OpenTelemetry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third parties like OpenTelemetry.\n\n## References\n- [OpenTelemetry Docs](https://opentelemetry.io/docs/)\n","markdown":"## Description\n\nLeaking sensitive data to third parties like OpenTelemetry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third parties like OpenTelemetry.\n\n## References\n- [OpenTelemetry Docs](https://opentelemetry.io/docs/)\n"}},{"id":"java_lang_exception","name":"java_lang_exception","shortDescription":{"text":"Leakage of sensitive data in exception message"},"fullDescription":{"text":"Leakage of sensitive data in exception message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeakage of sensitive data in exception messages can lead to data breaches. This vulnerability occurs when sensitive information is included in exceptions, making it accessible to unauthorized users.\n\n## Remediations\n\n- **Do not** include sensitive data in exception messages. This can inadvertently expose private information.\n  ```java\n  throw new Exception(\"error for \" + user.email);\n  ```\n- **Do** use non-sensitive, unique identifiers in exception messages to avoid revealing personal identifiable information (PII).\n  ```java\n  throw new Exception(\"error for \" + user.id);\n  ```","markdown":"## Description\n\nLeakage of sensitive data in exception messages can lead to data breaches. This vulnerability occurs when sensitive information is included in exceptions, making it accessible to unauthorized users.\n\n## Remediations\n\n- **Do not** include sensitive data in exception messages. This can inadvertently expose private information.\n  ```java\n  throw new Exception(\"error for \" + user.email);\n  ```\n- **Do** use non-sensitive, unique identifiers in exception messages to avoid revealing personal identifiable information (PII).\n  ```java\n  throw new Exception(\"error for \" + user.id);\n  ```"}},{"id":"javascript_lang_hardcoded_secret","name":"javascript_lang_hardcoded_secret","shortDescription":{"text":"Usage of hard-coded secret"},"fullDescription":{"text":"Usage of hard-coded secret"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nStoring secrets directly in your code is a security risk. Instead, opt for environment variables or a secret management system to safeguard your secrets.\n\n## Remediations\n\n- **Do not** store plaintext secrets in your code. This exposes sensitive information to unnecessary risk.\n  ```javascript\n    passport.use(new OAuth2Strategy({\n        authorizationURL: 'https://www.example.com/oauth2/authorize',\n        tokenURL: 'https://www.example.com/oauth2/token',\n        clientID: 'my-id-123',\n        clientSecret: 'shh-my-secret',\n        callbackURL: 'http://localhost:3000/auth/example/callback'\n      },\n      function(accessToken, refreshToken, profile, cb) {\n        User.findOrCreate({ exampleId: profile.id }, function (err, user) {\n          return cb(err, user);\n        });\n      }\n    ));\n  ```\n- **Do** use environment variables to store sensitive information such as secrets. This method keeps credentials out of your codebase and makes them easier to manage securely.\n- **Do** consider implementing a key-management system to securely handle secrets and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)\n- [Google Cloud Key Management Service](https://cloud.google.com/kms/docs)\n- [AWS Key Management Service](https://aws.amazon.com/kms/)","markdown":"## Description\n\nStoring secrets directly in your code is a security risk. Instead, opt for environment variables or a secret management system to safeguard your secrets.\n\n## Remediations\n\n- **Do not** store plaintext secrets in your code. This exposes sensitive information to unnecessary risk.\n  ```javascript\n    passport.use(new OAuth2Strategy({\n        authorizationURL: 'https://www.example.com/oauth2/authorize',\n        tokenURL: 'https://www.example.com/oauth2/token',\n        clientID: 'my-id-123',\n        clientSecret: 'shh-my-secret',\n        callbackURL: 'http://localhost:3000/auth/example/callback'\n      },\n      function(accessToken, refreshToken, profile, cb) {\n        User.findOrCreate({ exampleId: profile.id }, function (err, user) {\n          return cb(err, user);\n        });\n      }\n    ));\n  ```\n- **Do** use environment variables to store sensitive information such as secrets. This method keeps credentials out of your codebase and makes them easier to manage securely.\n- **Do** consider implementing a key-management system to securely handle secrets and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)\n- [Google Cloud Key Management Service](https://cloud.google.com/kms/docs)\n- [AWS Key Management Service](https://aws.amazon.com/kms/)"}},{"id":"java_lang_http_url_using_user_input","name":"java_lang_http_url_using_user_input","shortDescription":{"text":"Unsanitized user input in HTTP request (SSRF)"},"fullDescription":{"text":"Unsanitized user input in HTTP request (SSRF)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nDirectly incorporating user input into HTTP request URLs can lead to Server-Side Request Forgery (SSRF) attacks. This vulnerability occurs when an attacker can control the destination of an HTTP request sent by the server.\n\n## Remediations\n\n- **Do not** concatenate or include user input directly in URLs for HTTP requests. This practice can allow attackers to manipulate requests to unauthorized or malicious sites.\n  ```java\n  new URL(request.getParameter(\"someRandomUrl\")).getContent(); // unsafe\n  ```\n- **Do** validate or map user inputs to predefined options before using them to construct URLs. This approach ensures that the application only requests URLs to known, safe destinations.\n  ```java\n  String url;\n  if (request.getParameter(\"selectedUrl\").equals(\"option1\")) {\n    url = \"https://api1.com\";\n  } else {\n    url = \"https://api2.com\";\n  }\n\n  new URL(url).getContent();\n  ```","markdown":"## Description\n\nDirectly incorporating user input into HTTP request URLs can lead to Server-Side Request Forgery (SSRF) attacks. This vulnerability occurs when an attacker can control the destination of an HTTP request sent by the server.\n\n## Remediations\n\n- **Do not** concatenate or include user input directly in URLs for HTTP requests. This practice can allow attackers to manipulate requests to unauthorized or malicious sites.\n  ```java\n  new URL(request.getParameter(\"someRandomUrl\")).getContent(); // unsafe\n  ```\n- **Do** validate or map user inputs to predefined options before using them to construct URLs. This approach ensures that the application only requests URLs to known, safe destinations.\n  ```java\n  String url;\n  if (request.getParameter(\"selectedUrl\").equals(\"option1\")) {\n    url = \"https://api1.com\";\n  } else {\n    url = \"https://api2.com\";\n  }\n\n  new URL(url).getContent();\n  ```"}},{"id":"java_lang_permissive_cookie_config","name":"java_lang_permissive_cookie_config","shortDescription":{"text":"Permissive cookie configuration"},"fullDescription":{"text":"Permissive cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing overly permissive cookie settings can expose your application to security risks, such as unauthorized access or exploits.\n\n## Remediations\n\n- **Do not** set the cookie's max age to -1. This persists the cookie until the browser session ends and is a security risk.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setMaxAge(-1); // unsafe\n  ```\n- **Do not** set the cookie's path to \"/\". This makes the cookie accessible to all paths in the domain. Such permissive cookie exposure is a security risk.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setPath(\"/\"); // unsafe\n  ```\n- **Do** set a limited maximum age for cookies to control their lifespan effectively.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setMaxAge(3000);\n  ```\n- **Do** restrict the cookie's path to limit its accessibility to specific parts of your application. This practice enhances security by reducing the cookie's exposure.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setPath(\"/my-cookie-path\");\n  ```","markdown":"## Description\n\nUsing overly permissive cookie settings can expose your application to security risks, such as unauthorized access or exploits.\n\n## Remediations\n\n- **Do not** set the cookie's max age to -1. This persists the cookie until the browser session ends and is a security risk.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setMaxAge(-1); // unsafe\n  ```\n- **Do not** set the cookie's path to \"/\". This makes the cookie accessible to all paths in the domain. Such permissive cookie exposure is a security risk.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setPath(\"/\"); // unsafe\n  ```\n- **Do** set a limited maximum age for cookies to control their lifespan effectively.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setMaxAge(3000);\n  ```\n- **Do** restrict the cookie's path to limit its accessibility to specific parts of your application. This practice enhances security by reducing the cookie's exposure.\n  ```java\n  Cookie cookie = new Cookie(\"name\", \"value\");\n  cookie.setPath(\"/my-cookie-path\");\n  ```"}},{"id":"javascript_lang_logger","name":"javascript_lang_logger","shortDescription":{"text":"Leakage of sensitive information in logger message"},"fullDescription":{"text":"Leakage of sensitive information in logger message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nSensitive information leakage through logger messages can compromise user privacy and security. This vulnerability occurs when sensitive data, such as personal identifiable information (PII), is included in log messages, making it accessible to unauthorized individuals.\n\n## Remediations\n\n- **Do not** include sensitive data in logger messages. This can lead to unintended exposure of private information.\n  ```javascript\n  logger.info(`User is: ${user.email}`) // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers to reference users in log messages. This approach maintains user privacy while still allowing for effective logging.\n  ```javascript\n  logger.info(`User is: ${user.uuid}`)\n  ```\n## References\n\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)","markdown":"## Description\n\nSensitive information leakage through logger messages can compromise user privacy and security. This vulnerability occurs when sensitive data, such as personal identifiable information (PII), is included in log messages, making it accessible to unauthorized individuals.\n\n## Remediations\n\n- **Do not** include sensitive data in logger messages. This can lead to unintended exposure of private information.\n  ```javascript\n  logger.info(`User is: ${user.email}`) // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers to reference users in log messages. This approach maintains user privacy while still allowing for effective logging.\n  ```javascript\n  logger.info(`User is: ${user.uuid}`)\n  ```\n## References\n\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)"}},{"id":"javascript_lang_weak_password_hash_argon2","name":"javascript_lang_weak_password_hash_argon2","shortDescription":{"text":"Usage of weak hashing library on a password (Argon2)"},"fullDescription":{"text":"Usage of weak hashing library on a password (Argon2)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nChoosing a weak hashing algorithm for passwords compromises security. Argon2 has three variants: Argon2i, Argon2d, and Argon2id. Argon2id is the strongest and most recommended for password hashing because of its balanced resistance against both side-channel and GPU attack vectors.\n\n## Remediations\n\n- **Do not** override the Argon2 type when implementing the Argon2 hashing library. Using Argon2id ensures the highest level of security for password storage.\n  ```javascript\n    const argon2 = require(\"argon2\");\n    const hash = await argon2.hash(req.params.password, { type: argon2.argon2i }) // unsafe\n  ```\n- **Do** rely on the default Argon2 type - Argon2id as it is the most secure.\n  ```javascript\n    const argon2 = require(\"argon2\");\n    const hash = await argon2.hash(req.params.password);\n  ```\n\n## References\n\n- [Argon2 type options](https://github.com/ranisalt/node-argon2/wiki/Options#type)\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)","markdown":"## Description\n\nChoosing a weak hashing algorithm for passwords compromises security. Argon2 has three variants: Argon2i, Argon2d, and Argon2id. Argon2id is the strongest and most recommended for password hashing because of its balanced resistance against both side-channel and GPU attack vectors.\n\n## Remediations\n\n- **Do not** override the Argon2 type when implementing the Argon2 hashing library. Using Argon2id ensures the highest level of security for password storage.\n  ```javascript\n    const argon2 = require(\"argon2\");\n    const hash = await argon2.hash(req.params.password, { type: argon2.argon2i }) // unsafe\n  ```\n- **Do** rely on the default Argon2 type - Argon2id as it is the most secure.\n  ```javascript\n    const argon2 = require(\"argon2\");\n    const hash = await argon2.hash(req.params.password);\n  ```\n\n## References\n\n- [Argon2 type options](https://github.com/ranisalt/node-argon2/wiki/Options#type)\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)"}},{"id":"java_lang_xpath_injection","name":"java_lang_xpath_injection","shortDescription":{"text":"Unsanitized user input in XPath"},"fullDescription":{"text":"Unsanitized user input in XPath"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input in XPath expressions can lead to XPath injection, whereby attackers can gain unauthorized access to sensitive information in XML documents. Ensure all variables passed into XPath `evaluate` or `compile` commands are properly sanitized.\n\n## Remediations\n\n- **Do** sanitize user input before incorporating it into XPath queries. This prevents XPath injection by ensuring that input values cannot manipulate the query structure.\n  ```java\n  public class Cls extends HttpServlet\n  {\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String userID = request.getParameter(\"userID\");\n          String sanitizedUserID = sanitize(userID); // Ensure sanitization\n\n          javax.xml.xpath.XPathFactory xpf = javax.xml.xpath.XPathFactory.newInstance();\n          javax.xml.xpath.XPath xp = xpf.newXPath();\n\n          String expression = \"/Users/User[@userID='\" + sanitizedUserID + \"']\";\n          String result = xp.evaluate(expression, xmlDocument);\n      }\n  }\n  ```\n- **Do not** directly concatenate or embed unsanitized user inputs into XPath expressions. This practice can lead to XPath injection vulnerabilities.\n\n## References\n\n- [XPATH Injection](https://owasp.org/www-community/attacks/XPATH_Injection)","markdown":"## Description\n\nUsing unsanitized user input in XPath expressions can lead to XPath injection, whereby attackers can gain unauthorized access to sensitive information in XML documents. Ensure all variables passed into XPath `evaluate` or `compile` commands are properly sanitized.\n\n## Remediations\n\n- **Do** sanitize user input before incorporating it into XPath queries. This prevents XPath injection by ensuring that input values cannot manipulate the query structure.\n  ```java\n  public class Cls extends HttpServlet\n  {\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String userID = request.getParameter(\"userID\");\n          String sanitizedUserID = sanitize(userID); // Ensure sanitization\n\n          javax.xml.xpath.XPathFactory xpf = javax.xml.xpath.XPathFactory.newInstance();\n          javax.xml.xpath.XPath xp = xpf.newXPath();\n\n          String expression = \"/Users/User[@userID='\" + sanitizedUserID + \"']\";\n          String result = xp.evaluate(expression, xmlDocument);\n      }\n  }\n  ```\n- **Do not** directly concatenate or embed unsanitized user inputs into XPath expressions. This practice can lead to XPath injection vulnerabilities.\n\n## References\n\n- [XPATH Injection](https://owasp.org/www-community/attacks/XPATH_Injection)"}},{"id":"java_lang_missing_integrity_check","name":"java_lang_missing_integrity_check","shortDescription":{"text":"Missing support for integrity check"},"fullDescription":{"text":"Missing support for integrity check"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIf a protocol does not include integrity checks (\"checksums\"), it is impossible to determine whether or not an attacker has interfered with or manipulated the transmitted data. This makes it difficult to confirm whether or not the transmitted data has been tampered with or altered by unauthorized parties (Man-in-the-Middle attack).\n\n## Remediations\n\n- **Do** use encryption schemes that include integrity checks to ensure the data has not been modified during transmission.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/GCM/PKCS5Padding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)","markdown":"## Description\n\nIf a protocol does not include integrity checks (\"checksums\"), it is impossible to determine whether or not an attacker has interfered with or manipulated the transmitted data. This makes it difficult to confirm whether or not the transmitted data has been tampered with or altered by unauthorized parties (Man-in-the-Middle attack).\n\n## Remediations\n\n- **Do** use encryption schemes that include integrity checks to ensure the data has not been modified during transmission.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/GCM/PKCS5Padding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)"}},{"id":"javascript_lang_manual_html_sanitization","name":"javascript_lang_manual_html_sanitization","shortDescription":{"text":"Usage of manual HTML sanitization (XSS)"},"fullDescription":{"text":"Usage of manual HTML sanitization (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nManually sanitizing HTML is prone to mistakes and can lead to Cross-Site Scripting (XSS) vulnerabilities. This occurs when user input is not properly sanitized, allowing attackers to inject malicious scripts into web pages viewed by other users.\n\n## Remediations\n\n- **Do not** manually escape HTML to sanitize user input. This method is unreliable and can easily miss certain exploits.\n  ```javascript\n  const sanitizedUserInput = user.Input\n    .replaceAll('\u003c', '\u0026lt;')\n    .replaceAll('\u003e', '\u0026gt;'); // unsafe\n  const html = `\u003cstrong\u003e${sanitizedUserInput}\u003c/strong\u003e`;\n  ```\n- **Do** use a trusted HTML sanitization library to handle user input safely. Libraries designed for sanitization are more reliable as they cover a wide range of XSS attack vectors.\n  ```javascript\n  import sanitizeHtml from 'sanitize-html';\n\n  const html = sanitizeHtml(`\u003cstrong\u003e${user.Input}\u003c/strong\u003e`);\n  ```\n\n## References\n\n- [OWASP XSS explained](https://owasp.org/www-community/attacks/xss/)","markdown":"## Description\n\nManually sanitizing HTML is prone to mistakes and can lead to Cross-Site Scripting (XSS) vulnerabilities. This occurs when user input is not properly sanitized, allowing attackers to inject malicious scripts into web pages viewed by other users.\n\n## Remediations\n\n- **Do not** manually escape HTML to sanitize user input. This method is unreliable and can easily miss certain exploits.\n  ```javascript\n  const sanitizedUserInput = user.Input\n    .replaceAll('\u003c', '\u0026lt;')\n    .replaceAll('\u003e', '\u0026gt;'); // unsafe\n  const html = `\u003cstrong\u003e${sanitizedUserInput}\u003c/strong\u003e`;\n  ```\n- **Do** use a trusted HTML sanitization library to handle user input safely. Libraries designed for sanitization are more reliable as they cover a wide range of XSS attack vectors.\n  ```javascript\n  import sanitizeHtml from 'sanitize-html';\n\n  const html = sanitizeHtml(`\u003cstrong\u003e${user.Input}\u003c/strong\u003e`);\n  ```\n\n## References\n\n- [OWASP XSS explained](https://owasp.org/www-community/attacks/xss/)"}},{"id":"javascript_third_parties_datadog","name":"javascript_third_parties_datadog","shortDescription":{"text":"Leakage of sensitive data to Datadog"},"fullDescription":{"text":"Leakage of sensitive data to Datadog"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Datadog is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Datadog.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    const StatsD = require(\"hot-shots\");\n    const client = new StatsD({\n      port: 8020,\n      globalTags: { env: process.env.NODE_ENV },\n      errorHandler: errorHandler,\n    });\n\n    client.event(user.uuid, \"logged_in\", {});\n  ```\n\n## References\n- [Datadog docs](https://docs.datadoghq.com)\n- [Scrubbing data](https://docs.datadoghq.com/tracing/configure_data_security/?tab=mongodb#scrub-sensitive-data-from-your-spans)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Datadog is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Datadog.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    const StatsD = require(\"hot-shots\");\n    const client = new StatsD({\n      port: 8020,\n      globalTags: { env: process.env.NODE_ENV },\n      errorHandler: errorHandler,\n    });\n\n    client.event(user.uuid, \"logged_in\", {});\n  ```\n\n## References\n- [Datadog docs](https://docs.datadoghq.com)\n- [Scrubbing data](https://docs.datadoghq.com/tracing/configure_data_security/?tab=mongodb#scrub-sensitive-data-from-your-spans)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n"}},{"id":"javascript_lang_jwt","name":"javascript_lang_jwt","shortDescription":{"text":"Leakage of sensitive data in JWT"},"fullDescription":{"text":"Leakage of sensitive data in JWT"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nStoring sensitive data in JWTs exposes it to potential security risks. JWTs are designed for transmitting data securely among parties but are not inherently secure storage for sensitive information.\n\n## Remediations\n\n- **Do not** include sensitive data, such as email addresses, in JWTs. This can lead to unauthorized access to personal information.\n  ```javascript\n  const jwt = require('jsonwebtoken');\n  const token = jwt.sign({ user: { email: 'john@gmail.com' }}); // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers like a user's UUID in JWTs to reference user information securely.\n  ```javascript\n  const jwt = require('jsonwebtoken');\n  const token = jwt.sign({ user: user.uuid });\n  ```\n\n## References\n\n- [OWASP sensitive data exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)","markdown":"## Description\n\nStoring sensitive data in JWTs exposes it to potential security risks. JWTs are designed for transmitting data securely among parties but are not inherently secure storage for sensitive information.\n\n## Remediations\n\n- **Do not** include sensitive data, such as email addresses, in JWTs. This can lead to unauthorized access to personal information.\n  ```javascript\n  const jwt = require('jsonwebtoken');\n  const token = jwt.sign({ user: { email: 'john@gmail.com' }}); // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers like a user's UUID in JWTs to reference user information securely.\n  ```javascript\n  const jwt = require('jsonwebtoken');\n  const token = jwt.sign({ user: user.uuid });\n  ```\n\n## References\n\n- [OWASP sensitive data exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)"}},{"id":"javascript_lang_http_insecure","name":"javascript_lang_http_insecure","shortDescription":{"text":"Usage of insecure HTTP connection"},"fullDescription":{"text":"Usage of insecure HTTP connection"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour application is at risk when it connects to APIs using insecure HTTP connections. This vulnerability occurs because HTTP does not encrypt data, making it susceptible to interception and alteration. Ensure that your application uses HTTPS, which encrypts data in transit, for all connections.\n\n## Remediations\n\n- **Do not** use HTTP for outgoing connections or API calls. This practice leaves your data vulnerable to eavesdropping and tampering.\n  ```javascript\n  const response = axios.get('http://insecure-api.com') // unsafe\n  ```\n- **Do** ensure all external connections, especially API calls, use HTTPS to protect data in transit.\n  ```javascript\n  const response = axios.get('https://secure-api.com')\n  ```\n\n## References\n\n- [OWASP insecure transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)","markdown":"## Description\n\nYour application is at risk when it connects to APIs using insecure HTTP connections. This vulnerability occurs because HTTP does not encrypt data, making it susceptible to interception and alteration. Ensure that your application uses HTTPS, which encrypts data in transit, for all connections.\n\n## Remediations\n\n- **Do not** use HTTP for outgoing connections or API calls. This practice leaves your data vulnerable to eavesdropping and tampering.\n  ```javascript\n  const response = axios.get('http://insecure-api.com') // unsafe\n  ```\n- **Do** ensure all external connections, especially API calls, use HTTPS to protect data in transit.\n  ```javascript\n  const response = axios.get('https://secure-api.com')\n  ```\n\n## References\n\n- [OWASP insecure transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)"}},{"id":"java_lang_weak_encryption_ecb_mode","name":"java_lang_weak_encryption_ecb_mode","shortDescription":{"text":"Usage of ECB cipher mode"},"fullDescription":{"text":"Usage of ECB cipher mode"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe ECB (Electronic Codebook) cipher mode is recognized as insecure and is not recommended for use in cryptographic protocols. This mode does not provide adequate data protection because it encrypts identical plaintext blocks into identical ciphertext blocks, making it vulnerable to pattern analysis. For stronger security, it's essential to use encryption algorithms that have built-in message integrity and do not require a mode of operation to be configured, such as ChaCha20-Poly1305 or, for older applications that do not support this, AES-256-GCM.\n\n## Remediations\n\n- **Do** choose ChaCha20-Poly1305 or AES-256-GCM for encryption. These algorithms include built-in message integrity, offering a more secure alternative to ECB mode.\n  ```java\n  Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)","markdown":"## Description\n\nThe ECB (Electronic Codebook) cipher mode is recognized as insecure and is not recommended for use in cryptographic protocols. This mode does not provide adequate data protection because it encrypts identical plaintext blocks into identical ciphertext blocks, making it vulnerable to pattern analysis. For stronger security, it's essential to use encryption algorithms that have built-in message integrity and do not require a mode of operation to be configured, such as ChaCha20-Poly1305 or, for older applications that do not support this, AES-256-GCM.\n\n## Remediations\n\n- **Do** choose ChaCha20-Poly1305 or AES-256-GCM for encryption. These algorithms include built-in message integrity, offering a more secure alternative to ECB mode.\n  ```java\n  Cipher chaChaCipher = Cipher.getInstance(\"ChaCha20-Poly1305/None/NoPadding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)"}},{"id":"javascript_third_parties_sentry","name":"javascript_third_parties_sentry","shortDescription":{"text":"Leakage of sensitive data to Sentry"},"fullDescription":{"text":"Leakage of sensitive data to Sentry"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Sentry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Sentry.\n\n## References\n- [Sentry Docs](https://docs.sentry.io/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Sentry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Sentry.\n\n## References\n- [Sentry Docs](https://docs.sentry.io/)\n"}},{"id":"java_lang_rsa_no_padding","name":"java_lang_rsa_no_padding","shortDescription":{"text":"Missing Optimal Asymmetric Encryption Padding (OAEP)"},"fullDescription":{"text":"Missing Optimal Asymmetric Encryption Padding (OAEP)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe RSA encryption algorithm becomes vulnerable without Optimal Asymmetric Encryption Padding (OAEP). This vulnerability can lead to security risks such as information disclosure.\n\n## Remediations\n\n- **Do** always use OAEP with RSA encryption to enhance security and mitigate vulnerabilities.\n  ```java\n  Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithMD5AndMGF1Padding\")\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/javase/8/docs/api/java/security/MessageDigest.html)","markdown":"## Description\n\nThe RSA encryption algorithm becomes vulnerable without Optimal Asymmetric Encryption Padding (OAEP). This vulnerability can lead to security risks such as information disclosure.\n\n## Remediations\n\n- **Do** always use OAEP with RSA encryption to enhance security and mitigate vulnerabilities.\n  ```java\n  Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithMD5AndMGF1Padding\")\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/javase/8/docs/api/java/security/MessageDigest.html)"}},{"id":"javascript_third_parties_datadog_browser","name":"javascript_third_parties_datadog_browser","shortDescription":{"text":"Leakage of sensitive data to Datadog RUM"},"fullDescription":{"text":"Leakage of sensitive data to Datadog RUM"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nSensitive and private data contained in your pages may be sent to Datadog to identify elements that a user interacted with.\n\n## Remediations\n\n- **Do** control which information is sent to Datadog by either manually setting an action name or implementing a global scrubbing rule in the Datadog Browser SDK for RUM.\n\n## Resources\n- [Datadog docs](https://docs.datadoghq.com)\n- [Scrubbing data](https://docs.datadoghq.com/real_user_monitoring/browser/modifying_data_and_context/?tab=npm)\n","markdown":"## Description\n\nSensitive and private data contained in your pages may be sent to Datadog to identify elements that a user interacted with.\n\n## Remediations\n\n- **Do** control which information is sent to Datadog by either manually setting an action name or implementing a global scrubbing rule in the Datadog Browser SDK for RUM.\n\n## Resources\n- [Datadog docs](https://docs.datadoghq.com)\n- [Scrubbing data](https://docs.datadoghq.com/real_user_monitoring/browser/modifying_data_and_context/?tab=npm)\n"}},{"id":"javascript_third_parties_honeybadger","name":"javascript_third_parties_honeybadger","shortDescription":{"text":"Leakage of sensitive data to HoneyBadget"},"fullDescription":{"text":"Leakage of sensitive data to HoneyBadget"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Honeybadger is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Honeybadger.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    const Honeybadger = require(\"@honeybadger-io/js\");\n\n    let context = { user: { uuid: \"aacd05fd-8f5b-4bc6-aa8b-35e5fbf37325\" } };\n\n    Honeybadger.setContext(context);\n  ```\n\n## References\n- [Honeybadger Docs](https://docs.honeybadger.io/lib/javascript/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Honeybadger is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Honeybadger.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    const Honeybadger = require(\"@honeybadger-io/js\");\n\n    let context = { user: { uuid: \"aacd05fd-8f5b-4bc6-aa8b-35e5fbf37325\" } };\n\n    Honeybadger.setContext(context);\n  ```\n\n## References\n- [Honeybadger Docs](https://docs.honeybadger.io/lib/javascript/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n"}},{"id":"javascript_express_jwt_not_revoked","name":"javascript_express_jwt_not_revoked","shortDescription":{"text":"Missing revoke method on JWT"},"fullDescription":{"text":"Missing revoke method on JWT"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nFailing to implement a revoke method for JSON Web Tokens (JWTs) can lead to security vulnerabilities, especially when the tokens contain sensitive information. In order to maintain the integrity and confidentiality of any data contained within JWTs, it is best practice caching policy to always revoke them.\n\n## Remediations\n\n- **Do** ensure JWTs are short-lived by implementing a method to revoke them. This reduces the risk of unauthorized access to sensitive information.\n  ```javascript\n  expressjwt({\n    ...\n    isRevoked: this.customRevokeCall(),\n    ...\n  })\n  ```\n\n## References\n\n- [ExpressJWT documentation on revoking tokens](https://github.com/auth0/express-jwt#revoked-tokens)","markdown":"## Description\n\nFailing to implement a revoke method for JSON Web Tokens (JWTs) can lead to security vulnerabilities, especially when the tokens contain sensitive information. In order to maintain the integrity and confidentiality of any data contained within JWTs, it is best practice caching policy to always revoke them.\n\n## Remediations\n\n- **Do** ensure JWTs are short-lived by implementing a method to revoke them. This reduces the risk of unauthorized access to sensitive information.\n  ```javascript\n  expressjwt({\n    ...\n    isRevoked: this.customRevokeCall(),\n    ...\n  })\n  ```\n\n## References\n\n- [ExpressJWT documentation on revoking tokens](https://github.com/auth0/express-jwt#revoked-tokens)"}},{"id":"javascript_express_default_cookie_config","name":"javascript_express_default_cookie_config","shortDescription":{"text":"Usage of default cookie configuration"},"fullDescription":{"text":"Usage of default cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing default cookie configurations can expose your application to security risks. This vulnerability arises when cookies are set with their default values, making them predictable and easier to exploit.\n\n## Remediations\n\n- **Do not** rely on default cookie names.\n- **Do** use generic, non-descriptive names for session cookies. This makes it harder for attackers to identify and exploit the session management mechanism of your application.\n- **Do** always specify a `maxAge` or `expires` value to control cookie lifetime.\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)","markdown":"## Description\n\nUsing default cookie configurations can expose your application to security risks. This vulnerability arises when cookies are set with their default values, making them predictable and easier to exploit.\n\n## Remediations\n\n- **Do not** rely on default cookie names.\n- **Do** use generic, non-descriptive names for session cookies. This makes it harder for attackers to identify and exploit the session management mechanism of your application.\n- **Do** always specify a `maxAge` or `expires` value to control cookie lifetime.\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)"}},{"id":"java_lang_open_redirect","name":"java_lang_open_redirect","shortDescription":{"text":"Unsanitized user input in redirect"},"fullDescription":{"text":"Unsanitized user input in redirect"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input to perform redirects can make your application vulnerable to phishing attacks. This occurs when user input is directly used to determine the destination of a redirect without proper validation or sanitization, allowing attackers to redirect users to malicious sites, potentially compromising their security.\n\n## Remediations\n\n- **Do not** use unsanitized user input to construct URLs for redirects. This can lead to phishing attacks and compromise user security.\n- **Do** validate user input by employing a safe list or a mapping strategy when constructing URLs for redirects. This ensures that only pre-approved destinations are used, significantly reducing the risk of malicious redirects.\n  ```java\n  private static final Map\u003cString, String\u003e URL_MAPPING = new HashMap\u003c\u003e();\n  static {\n    URL_MAPPING.put(\"google\", \"https://www.google.com\");\n    URL_MAPPING.put(\"openai\", \"https://www.openai.com\");\n    URL_MAPPING.put(\"github\", \"https://www.github.com\");\n    URL_MAPPING.put(\"root\", \"https://www.example.com\");\n  }\n\n  String redirectUrl = URL_MAPPING.getOrDefault(request.getParameter(\"redirectTo\"), \"root\");\n  response.addHeader(\"Location\", redirectUrl);\n  ```\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized user input to perform redirects can make your application vulnerable to phishing attacks. This occurs when user input is directly used to determine the destination of a redirect without proper validation or sanitization, allowing attackers to redirect users to malicious sites, potentially compromising their security.\n\n## Remediations\n\n- **Do not** use unsanitized user input to construct URLs for redirects. This can lead to phishing attacks and compromise user security.\n- **Do** validate user input by employing a safe list or a mapping strategy when constructing URLs for redirects. This ensures that only pre-approved destinations are used, significantly reducing the risk of malicious redirects.\n  ```java\n  private static final Map\u003cString, String\u003e URL_MAPPING = new HashMap\u003c\u003e();\n  static {\n    URL_MAPPING.put(\"google\", \"https://www.google.com\");\n    URL_MAPPING.put(\"openai\", \"https://www.openai.com\");\n    URL_MAPPING.put(\"github\", \"https://www.github.com\");\n    URL_MAPPING.put(\"root\", \"https://www.example.com\");\n  }\n\n  String redirectUrl = URL_MAPPING.getOrDefault(request.getParameter(\"redirectTo\"), \"root\");\n  response.addHeader(\"Location\", redirectUrl);\n  ```\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)"}},{"id":"java_lang_logger","name":"java_lang_logger","shortDescription":{"text":"Leakage of sensitive information in logger message"},"fullDescription":{"text":"Leakage of sensitive information in logger message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nSensitive information leakage in logger messages can compromise user privacy and security. This vulnerability occurs when sensitive data, such as personal identifiable information (PII), is included in log messages, making it accessible to unauthorized individuals.\n\n## Remediations\n\n- **Do not** include sensitive data in logger messages. This can lead to unintended exposure of personal or confidential information.\n  ```java\n  logger.info(user.email) // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers to refer to users or entities in log messages. This approach maintains privacy while still allowing for effective logging.\n  ```java\n  logger.info(user.uuid)\n  ```\n- **Do** log static messages that do not contain dynamic variables or attributes. This minimizes the risk of accidentally logging sensitive information.\n  ```java\n  logger.info(\"user signed in\")\n  ```\n\n## References\n\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)","markdown":"## Description\n\nSensitive information leakage in logger messages can compromise user privacy and security. This vulnerability occurs when sensitive data, such as personal identifiable information (PII), is included in log messages, making it accessible to unauthorized individuals.\n\n## Remediations\n\n- **Do not** include sensitive data in logger messages. This can lead to unintended exposure of personal or confidential information.\n  ```java\n  logger.info(user.email) // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers to refer to users or entities in log messages. This approach maintains privacy while still allowing for effective logging.\n  ```java\n  logger.info(user.uuid)\n  ```\n- **Do** log static messages that do not contain dynamic variables or attributes. This minimizes the risk of accidentally logging sensitive information.\n  ```java\n  logger.info(\"user signed in\")\n  ```\n\n## References\n\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)"}},{"id":"javascript_third_parties_algolia","name":"javascript_third_parties_algolia","shortDescription":{"text":"Leakage of sensitive data to Algolia"},"fullDescription":{"text":"Leakage of sensitive data to Algolia"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party data tools like Algolia is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like Algolia.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    const algoliaSearch = require('algoliasearch')\n    const myAlgolia = algoliaSearch(\"123\", \"123\")\n    const index = myAlgolia.initIndex(user.uuid)\n  ```\n\n## References\n- [Algolia docs](https://www.algolia.com/doc/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party data tools like Algolia is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like Algolia.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    const algoliaSearch = require('algoliasearch')\n    const myAlgolia = algoliaSearch(\"123\", \"123\")\n    const index = myAlgolia.initIndex(user.uuid)\n  ```\n\n## References\n- [Algolia docs](https://www.algolia.com/doc/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n"}},{"id":"javascript_lang_regex_using_user_input","name":"javascript_lang_regex_using_user_input","shortDescription":{"text":"Unsanitized user input in regular expression"},"fullDescription":{"text":"Unsanitized user input in regular expression"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nCreating regular expressions from user input can lead to a vulnerability known as Regular Expression Denial of Service (ReDoS). This issue arises because some regular expressions can be processed with exponential time complexity. When attackers exploit this, it can significantly drain CPU resources, effectively causing a denial of service.\n\n## Remediations\n\n- **Do not** use user-supplied data directly in regular expressions. This can prevent attackers from exploiting the ReDoS vulnerability to cause a denial of service.\n  ```javascript\n  new RegExp(`abc${req.params.untrusted}`, 'i'); // unsafe\n  ```\n- **Do** sanitize or validate all user input if it must be used in a regular expression, to ensure it does not contain patterns that can lead to ReDoS attacks.\n- **Do** consider implementing timeouts or other limitations on regex operations to mitigate potential ReDoS attacks when user input is involved.\n\n## References\n\n- [OWASP ReDoS attacks explained](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)","markdown":"## Description\n\nCreating regular expressions from user input can lead to a vulnerability known as Regular Expression Denial of Service (ReDoS). This issue arises because some regular expressions can be processed with exponential time complexity. When attackers exploit this, it can significantly drain CPU resources, effectively causing a denial of service.\n\n## Remediations\n\n- **Do not** use user-supplied data directly in regular expressions. This can prevent attackers from exploiting the ReDoS vulnerability to cause a denial of service.\n  ```javascript\n  new RegExp(`abc${req.params.untrusted}`, 'i'); // unsafe\n  ```\n- **Do** sanitize or validate all user input if it must be used in a regular expression, to ensure it does not contain patterns that can lead to ReDoS attacks.\n- **Do** consider implementing timeouts or other limitations on regex operations to mitigate potential ReDoS attacks when user input is involved.\n\n## References\n\n- [OWASP ReDoS attacks explained](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)"}},{"id":"java_third_parties_sentry","name":"java_third_parties_sentry","shortDescription":{"text":"Leakage of sensitive data to Sentry"},"fullDescription":{"text":"Leakage of sensitive data to Sentry"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Sentry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Sentry.\n\n## References\n- [Sentry Docs](https://docs.sentry.io/platforms/java/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Sentry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Sentry.\n\n## References\n- [Sentry Docs](https://docs.sentry.io/platforms/java/)\n"}},{"id":"java_lang_cookie_leak","name":"java_lang_cookie_leak","shortDescription":{"text":"Leakage of sensitive data in cookie"},"fullDescription":{"text":"Leakage of sensitive data in cookie"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeakage of sensitive data in cookies can lead to a data breach. This vulnerability occurs when sensitive information is stored in browser cookies, putting it at risk of unauthorized access.\n\n## Remediations\n\n- **Do not** store sensitive data in unencrypted cookies. This practice can expose sensitive information to potential security threats.\n  ```java\n  Cookie cookie = new Cookie(\"user\", user.email);\n  ```","markdown":"## Description\n\nLeakage of sensitive data in cookies can lead to a data breach. This vulnerability occurs when sensitive information is stored in browser cookies, putting it at risk of unauthorized access.\n\n## Remediations\n\n- **Do not** store sensitive data in unencrypted cookies. This practice can expose sensitive information to potential security threats.\n  ```java\n  Cookie cookie = new Cookie(\"user\", user.email);\n  ```"}},{"id":"javascript_third_parties_dynamodb_query_injection","name":"javascript_third_parties_dynamodb_query_injection","shortDescription":{"text":"Unsanitized user input in DynamoDB query"},"fullDescription":{"text":"Unsanitized user input in DynamoDB query"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncluding unsanitized data, such as user input or request data, in raw queries makes your application vulnerable to injection attacks.\n\n## Remediations\n\n- **Do** narrow down your query from the code instead of using unsanitzed user input to define it.\n  ```javascript\n  exports.handler = async function(event, context) {\n      var params = {\n          Key: {\n          \"artist\": {\"S\": event.input },\n          \"song\": {\"S\": \"Carrot Eton\"}\n          },\n          TableName: \"artists\"\n      };\n      var result = await dynamodb.getItem(params).promise()\n      console.log(JSON.stringify(result))\n  }\n  ```\n\n## References\n\n- [OWASP nosql injection explained](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection)\n","markdown":"## Description\n\nIncluding unsanitized data, such as user input or request data, in raw queries makes your application vulnerable to injection attacks.\n\n## Remediations\n\n- **Do** narrow down your query from the code instead of using unsanitzed user input to define it.\n  ```javascript\n  exports.handler = async function(event, context) {\n      var params = {\n          Key: {\n          \"artist\": {\"S\": event.input },\n          \"song\": {\"S\": \"Carrot Eton\"}\n          },\n          TableName: \"artists\"\n      };\n      var result = await dynamodb.getItem(params).promise()\n      console.log(JSON.stringify(result))\n  }\n  ```\n\n## References\n\n- [OWASP nosql injection explained](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection)\n"}},{"id":"javascript_express_static_asset_with_session","name":"javascript_express_static_asset_with_session","shortDescription":{"text":"Usage of session on static asset (CSRF)"},"fullDescription":{"text":"Usage of session on static asset (CSRF)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nEnabling sessions for static assets can inadvertently expose your application to Cross-Site Request Forgery (CSRF) attacks. This vulnerability arises because static assets, like images and stylesheets, are often cached by intermediary services such as Content Delivery Networks (CDNs). If these assets are served with session information, attackers can exploit this to hijack a user's session.\n\n## Remediations\n\n- **Do** ensure that static resources are served prior to session initialization in your application's middleware order. This practice prevents session cookies from being unnecessarily attached to static assets, reducing the risk of CSRF attacks.\n  ```javascript\n  app.use(express.static(__dirname + \"/public\"));\n  app.use(session());\n  ```","markdown":"## Description\n\nEnabling sessions for static assets can inadvertently expose your application to Cross-Site Request Forgery (CSRF) attacks. This vulnerability arises because static assets, like images and stylesheets, are often cached by intermediary services such as Content Delivery Networks (CDNs). If these assets are served with session information, attackers can exploit this to hijack a user's session.\n\n## Remediations\n\n- **Do** ensure that static resources are served prior to session initialization in your application's middleware order. This practice prevents session cookies from being unnecessarily attached to static assets, reducing the risk of CSRF attacks.\n  ```javascript\n  app.use(express.static(__dirname + \"/public\"));\n  app.use(session());\n  ```"}},{"id":"java_third_parties_datadog","name":"java_third_parties_datadog","shortDescription":{"text":"Leakage of sensitive data to Datadog"},"fullDescription":{"text":"Leakage of sensitive data to Datadog"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Datadog is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Datadog.\n\n## References\n- [Datadog docs](https://docs.datadoghq.com)\n- [Scrubbing data](https://docs.datadoghq.com/tracing/configure_data_security/?tab=java#replace-tags)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Datadog is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Datadog.\n\n## References\n- [Datadog docs](https://docs.datadoghq.com)\n- [Scrubbing data](https://docs.datadoghq.com/tracing/configure_data_security/?tab=java#replace-tags)\n"}},{"id":"javascript_express_default_session_config","name":"javascript_express_default_session_config","shortDescription":{"text":"Usage of default session cookie configuration"},"fullDescription":{"text":"Usage of default session cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing default session cookie configurations can expose your application to security vulnerabilities. This vulnerability arises when session cookie are set with their default values, making them predictable and easier to exploit.\n\n## Remediations\n\n- **Do not** rely on the default session cookie names and values provided by your framework. These defaults can be easily guessed by attackers, increasing the risk of session hijacking.\n- **Do** use generic, non-descriptive names for session cookies. This makes it harder for attackers to identify and exploit the session management mechanism of your application.\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)","markdown":"## Description\n\nUsing default session cookie configurations can expose your application to security vulnerabilities. This vulnerability arises when session cookie are set with their default values, making them predictable and easier to exploit.\n\n## Remediations\n\n- **Do not** rely on the default session cookie names and values provided by your framework. These defaults can be easily guessed by attackers, increasing the risk of session hijacking.\n- **Do** use generic, non-descriptive names for session cookies. This makes it harder for attackers to identify and exploit the session management mechanism of your application.\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)"}},{"id":"java_lang_custom_message_digest_class","name":"java_lang_custom_message_digest_class","shortDescription":{"text":"Usage of custom Digest class"},"fullDescription":{"text":"Usage of custom Digest class"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nCreating your own Digest class is not recommended because manually implement cryptographic functions is a highly error-prone process. It's safer and more secure to rely on standard Digest algorithms like SHA-256 or SHA-512.\n\n## Remediations\n\n- **Do not** implement a custom Digest class manually. Custom implementations can lead to security vulnerabilities due to incorrect handling or flawed algorithms.\n- **Do** use established Digest algorithms such as SHA-256, SHA-384, SHA-512, or SHA-512/256. These standard algorithms have been thoroughly tested and are widely trusted for their security.\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)","markdown":"## Description\n\nCreating your own Digest class is not recommended because manually implement cryptographic functions is a highly error-prone process. It's safer and more secure to rely on standard Digest algorithms like SHA-256 or SHA-512.\n\n## Remediations\n\n- **Do not** implement a custom Digest class manually. Custom implementations can lead to security vulnerabilities due to incorrect handling or flawed algorithms.\n- **Do** use established Digest algorithms such as SHA-256, SHA-384, SHA-512, or SHA-512/256. These standard algorithms have been thoroughly tested and are widely trusted for their security.\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)"}},{"id":"java_lang_regex_using_user_input","name":"java_lang_regex_using_user_input","shortDescription":{"text":"Unsanitized user input in regular expression"},"fullDescription":{"text":"Unsanitized user input in regular expression"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nConstructing regular expressions from user input can lead to a vulnerability known as Regular Expression Denial of Service (ReDoS). This issue arises because certain regular expressions can be processed with exponential time complexity. If attackers exploit this, they can cause significant CPU usage spikes, effectively denying service to legitimate users.\n\n## Remediations\n\n- **Do not** - wherever possible - use user input directly in regular expressions. This can prevent attackers from exploiting complex patterns that cause excessive CPU consumption.\n  ```java\n  Pattern pattern = Pattern.compile(request.getParameter(\"dangerousRegex\"));\n  ```\n- **Do** sanitize or validate user input if it must be used in a regular expression. Ensure that the input does not contain patterns that could lead to ReDoS.\n\n## References\n\n- [OWASP ReDoS attacks explained](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)","markdown":"## Description\n\nConstructing regular expressions from user input can lead to a vulnerability known as Regular Expression Denial of Service (ReDoS). This issue arises because certain regular expressions can be processed with exponential time complexity. If attackers exploit this, they can cause significant CPU usage spikes, effectively denying service to legitimate users.\n\n## Remediations\n\n- **Do not** - wherever possible - use user input directly in regular expressions. This can prevent attackers from exploiting complex patterns that cause excessive CPU consumption.\n  ```java\n  Pattern pattern = Pattern.compile(request.getParameter(\"dangerousRegex\"));\n  ```\n- **Do** sanitize or validate user input if it must be used in a regular expression. Ensure that the input does not contain patterns that could lead to ReDoS.\n\n## References\n\n- [OWASP ReDoS attacks explained](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)"}},{"id":"java_lang_deserialization_of_user_input","name":"java_lang_deserialization_of_user_input","shortDescription":{"text":"Unsanitized user input in deserialization method"},"fullDescription":{"text":"Unsanitized user input in deserialization method"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIt is bad practice to deserialize untrusted data, such as data that comes from params or cookies, without sufficient verification. Attackers can transfer payloads or malicious code via serialized data, and deserializing such data puts your application at risk.\n\n## Remediations\n\n- **Do not** deserialize data from untrusted sources directly. This includes data received through user input, parameters, or cookies.\n- **Do not** use `XMLEncoder` and `XMLDecoder` for serialization and deserialization. These classes are not secure and can increase the risk of attacks.\n- **Do** use data-only and language-agnostic serialization formats like JSON. These formats are less susceptible to manipulation by attackers aiming to exploit the deserialization process.\n- **Do** use deserialization methods that allow you to define explicitly which object types are permitted for deserialization. This helps prevent the deserialization of potentially harmful objects.\n- **Do not** allow the deserialization of generic base object types, such as `Object`. Restricting the types of objects that can be deserialized minimizes the risk of executing malicious code.\n\n## References\n\n- [OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java)\n- [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)","markdown":"## Description\n\nIt is bad practice to deserialize untrusted data, such as data that comes from params or cookies, without sufficient verification. Attackers can transfer payloads or malicious code via serialized data, and deserializing such data puts your application at risk.\n\n## Remediations\n\n- **Do not** deserialize data from untrusted sources directly. This includes data received through user input, parameters, or cookies.\n- **Do not** use `XMLEncoder` and `XMLDecoder` for serialization and deserialization. These classes are not secure and can increase the risk of attacks.\n- **Do** use data-only and language-agnostic serialization formats like JSON. These formats are less susceptible to manipulation by attackers aiming to exploit the deserialization process.\n- **Do** use deserialization methods that allow you to define explicitly which object types are permitted for deserialization. This helps prevent the deserialization of potentially harmful objects.\n- **Do not** allow the deserialization of generic base object types, such as `Object`. Restricting the types of objects that can be deserialized minimizes the risk of executing malicious code.\n\n## References\n\n- [OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java)\n- [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)"}},{"id":"java_spring_sqli","name":"java_spring_sqli","shortDescription":{"text":"Unsanitized external input in SQL query"},"fullDescription":{"text":"Unsanitized external input in SQL query"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized data, such as user input or request data, or externally influenced data passed to a function, in SQL query exposes your application to SQL injection attacks. This vulnerability arises when externally controlled data is directly included in SQL statements without proper sanitation, allowing attackers to manipulate queries and access or modify data.\n\n## Remediations\n\n- **Do not** concatenate external input directly into SQL queries. This practice can lead to SQL injection vulnerabilities.\n  ```java\n  String query = \"update user set name='\"+uri.getQueryParameter(\"name\")+\"' where id='\"+uri.getQueryParameter(\"userId\")+\"'\";\n  return jdbcTemplate.update(query);\n  ```\n- **Do** use `PreparedStatement` with parameterized SQL queries to safely include external input. This method ensures that input is treated as data, not executable code.\n  ```java\n  new PreparedStatementCreator() {\n    public PreparedStatement createPreparedStatement(Connection conn) throws SQLException {\n      String updateString = \"update user set name = ? where id = ?\";\n      return conn.prepareStatement(updateString);\n    }\n  }\n\n  new PreparedStatementSetter() {\n    public void setValues(PreparedStatement preparedStatement) throws SQLException {\n      preparedStatement.setString(1, uri.getQueryParameter(\"name\"));\n      preparedStatement.setInt(2, uri.getQueryParameter(\"userId\"));\n    }\n  }\n  ```\n\n## References\n\n- [JDBC Template class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html)\n- [OWASP SQL injection explained](https://owasp.org/www-community/attacks/SQL_Injection)\n- [OWASP SQL injection prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized data, such as user input or request data, or externally influenced data passed to a function, in SQL query exposes your application to SQL injection attacks. This vulnerability arises when externally controlled data is directly included in SQL statements without proper sanitation, allowing attackers to manipulate queries and access or modify data.\n\n## Remediations\n\n- **Do not** concatenate external input directly into SQL queries. This practice can lead to SQL injection vulnerabilities.\n  ```java\n  String query = \"update user set name='\"+uri.getQueryParameter(\"name\")+\"' where id='\"+uri.getQueryParameter(\"userId\")+\"'\";\n  return jdbcTemplate.update(query);\n  ```\n- **Do** use `PreparedStatement` with parameterized SQL queries to safely include external input. This method ensures that input is treated as data, not executable code.\n  ```java\n  new PreparedStatementCreator() {\n    public PreparedStatement createPreparedStatement(Connection conn) throws SQLException {\n      String updateString = \"update user set name = ? where id = ?\";\n      return conn.prepareStatement(updateString);\n    }\n  }\n\n  new PreparedStatementSetter() {\n    public void setValues(PreparedStatement preparedStatement) throws SQLException {\n      preparedStatement.setString(1, uri.getQueryParameter(\"name\"));\n      preparedStatement.setInt(2, uri.getQueryParameter(\"userId\"));\n    }\n  }\n  ```\n\n## References\n\n- [JDBC Template class](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html)\n- [OWASP SQL injection explained](https://owasp.org/www-community/attacks/SQL_Injection)\n- [OWASP SQL injection prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)"}},{"id":"java_lang_insecure_cookie","name":"java_lang_insecure_cookie","shortDescription":{"text":"Missing Secure option in cookie configuration"},"fullDescription":{"text":"Missing Secure option in cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nWhen a cookie lacks the Secure option, it can be transmitted over insecure connections, making it vulnerable to interception by unauthorized parties. The Secure option is important because it instructs the browser to only send the cookie over HTTPS, enhancing security.\n\n## Remediations\n\n- **Do** set the `Secure` option to `true` for cookies to ensure they are only sent over HTTPS, enhancing the security of data transmission.\n  ```java\n  cookie.setSecure(true);\n  ```","markdown":"## Description\n\nWhen a cookie lacks the Secure option, it can be transmitted over insecure connections, making it vulnerable to interception by unauthorized parties. The Secure option is important because it instructs the browser to only send the cookie over HTTPS, enhancing security.\n\n## Remediations\n\n- **Do** set the `Secure` option to `true` for cookies to ensure they are only sent over HTTPS, enhancing the security of data transmission.\n  ```java\n  cookie.setSecure(true);\n  ```"}},{"id":"javascript_lang_non_literal_fs_filename","name":"javascript_lang_non_literal_fs_filename","shortDescription":{"text":"Unsanitized dynamic input in file path"},"fullDescription":{"text":"Unsanitized dynamic input in file path"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nAllowing unsanitized dynamic input in file paths can lead to unauthorized file and folder access. This vulnerability arises when dynamic data is used within the file system operations, potentially allowing attackers to access unauthorized or hidden files and folders.\n\n## Remediations\n\n- **Do** sanitize all dynamic data and function arguments before using them in file system operations. This step is crucial to prevent unauthorized access.\n- **Do** use a combination of hard-coded string literals and control logic, instead of directly passing dynamic data or function arguments to file system functions. This ensures safety.\n  ```javascript\n  function write(filename) {\n    switch(filename) {\n      case \"hello.txt\":\n        fs.writeCreateFile(\"hello.txt\");\n        break;\n      // Add more cases as necessary\n    }\n  }\n  ```\n\n## References\n\n- [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)","markdown":"## Description\n\nAllowing unsanitized dynamic input in file paths can lead to unauthorized file and folder access. This vulnerability arises when dynamic data is used within the file system operations, potentially allowing attackers to access unauthorized or hidden files and folders.\n\n## Remediations\n\n- **Do** sanitize all dynamic data and function arguments before using them in file system operations. This step is crucial to prevent unauthorized access.\n- **Do** use a combination of hard-coded string literals and control logic, instead of directly passing dynamic data or function arguments to file system functions. This ensures safety.\n  ```javascript\n  function write(filename) {\n    switch(filename) {\n      case \"hello.txt\":\n        fs.writeCreateFile(\"hello.txt\");\n        break;\n      // Add more cases as necessary\n    }\n  }\n  ```\n\n## References\n\n- [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)"}},{"id":"javascript_express_cross_site_scripting","name":"javascript_express_cross_site_scripting","shortDescription":{"text":"Unsanitized user input in HTTP response (XSS)"},"fullDescription":{"text":"Unsanitized user input in HTTP response (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncluding unsanitized user input in HTTP responses exposes your application to cross-site scripting (XSS) attacks. This vulnerability allows attackers to inject malicious scripts into web pages viewed by other users.\n\n## Remediations\n\n- **Do not** include user input directly in a response. This practice can lead to XSS vulnerabilities.\n  ```javascript\n  res.send(req.body.data); // unsafe\n  ```\n- **Do** sanitize user input before including it in a response. Use library functions or frameworks designed for input sanitization to ensure that user data cannot be interpreted as executable code.\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nIncluding unsanitized user input in HTTP responses exposes your application to cross-site scripting (XSS) attacks. This vulnerability allows attackers to inject malicious scripts into web pages viewed by other users.\n\n## Remediations\n\n- **Do not** include user input directly in a response. This practice can lead to XSS vulnerabilities.\n  ```javascript\n  res.send(req.body.data); // unsafe\n  ```\n- **Do** sanitize user input before including it in a response. Use library functions or frameworks designed for input sanitization to ensure that user data cannot be interpreted as executable code.\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)"}},{"id":"javascript_lang_weak_hash_sha1","name":"javascript_lang_weak_hash_sha1","shortDescription":{"text":"Usage of weak hashing library (SHA-1)"},"fullDescription":{"text":"Usage of weak hashing library (SHA-1)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a weak hashing library like SHA-1 increases the risk of data breaches. SHA-1 in particular is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing. It's no longer considered secure against well-funded attackers.\n  ```javascript\n  const hash = crypto.createHmac(\"sha1\", key).update(user.password); // unsafe\n  ```\n- **Do** use stronger hashing algorithms like SHA-256 or SHA-3 for enhanced security.\n  ```javascript\n  const hash = crypto.createHmac(\"sha256\", key).update(user.password);\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)","markdown":"## Description\n\nUsing a weak hashing library like SHA-1 increases the risk of data breaches. SHA-1 in particular is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing. It's no longer considered secure against well-funded attackers.\n  ```javascript\n  const hash = crypto.createHmac(\"sha1\", key).update(user.password); // unsafe\n  ```\n- **Do** use stronger hashing algorithms like SHA-256 or SHA-3 for enhanced security.\n  ```javascript\n  const hash = crypto.createHmac(\"sha256\", key).update(user.password);\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)"}},{"id":"javascript_lang_file_permissions","name":"javascript_lang_file_permissions","shortDescription":{"text":"Permissive file assignment"},"fullDescription":{"text":"Permissive file assignment"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nPermissive file assignment exposes sensitive information by granting unnecessary read, write, or execute permissions to users without ownership privileges.\n\n## Remediations\n\n- **Do** keep file permissions as restrictive as possible to minimize the risk of unauthorized access. Use the principle of least privilege to only grant permissions that are absolutely necessary for the operation of the application.\n  ```javascript\n  fs.chmod(path, 0o600);\n  ```\n- **Do** prefer assigning file permissions to 'groups' rather than 'other' when you need to extend privileges to users who are not the owners. This approach helps in limiting access to a more controlled set of users.","markdown":"## Description\n\nPermissive file assignment exposes sensitive information by granting unnecessary read, write, or execute permissions to users without ownership privileges.\n\n## Remediations\n\n- **Do** keep file permissions as restrictive as possible to minimize the risk of unauthorized access. Use the principle of least privilege to only grant permissions that are absolutely necessary for the operation of the application.\n  ```javascript\n  fs.chmod(path, 0o600);\n  ```\n- **Do** prefer assigning file permissions to 'groups' rather than 'other' when you need to extend privileges to users who are not the owners. This approach helps in limiting access to a more controlled set of users."}},{"id":"javascript_third_parties_segment","name":"javascript_third_parties_segment","shortDescription":{"text":"Leakage of sensitive data to Segment"},"fullDescription":{"text":"Leakage of sensitive data to Segment"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party analytics tools like Segment is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party analytics libraries like Segment.\n\n## References\n- [Segment Node.js docs](https://segment.com/docs/connections/sources/catalog/libraries/server/node/)\n- [Segment JavaScript docs](https://segment.com/docs/connections/sources/catalog/libraries/website/javascript/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party analytics tools like Segment is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party analytics libraries like Segment.\n\n## References\n- [Segment Node.js docs](https://segment.com/docs/connections/sources/catalog/libraries/server/node/)\n- [Segment JavaScript docs](https://segment.com/docs/connections/sources/catalog/libraries/website/javascript/)\n"}},{"id":"java_lang_cookie_missing_secure","name":"java_lang_cookie_missing_secure","shortDescription":{"text":"Missing Secure option in cookie configuration"},"fullDescription":{"text":"Missing Secure option in cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nNot setting the \"Secure\" attribute in cookie configuration can lead to unauthorized third-party access. This attribute, when enabled, ensures cookies are sent to the server only over HTTPS, enhancing security by preventing potential eavesdropping.\n\n## Remediations\n\n- **Do** set the `setSecure` attribute to `true` to enforce the transmission of cookies over HTTPS only.\n  ```java\n  cookie.setSecure(true);\n  ```","markdown":"## Description\n\nNot setting the \"Secure\" attribute in cookie configuration can lead to unauthorized third-party access. This attribute, when enabled, ensures cookies are sent to the server only over HTTPS, enhancing security by preventing potential eavesdropping.\n\n## Remediations\n\n- **Do** set the `setSecure` attribute to `true` to enforce the transmission of cookies over HTTPS only.\n  ```java\n  cookie.setSecure(true);\n  ```"}},{"id":"javascript_express_helmet_missing","name":"javascript_express_helmet_missing","shortDescription":{"text":"Missing Helmet configuration on HTTP headers"},"fullDescription":{"text":"Missing Helmet configuration on HTTP headers"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nHelmet can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately. Failing to configure Helmet for HTTP headers leaves your application vulnerable to several web attacks.\n\n## Remediations\n\n- **Do** use Helmet middleware to secure your app by adding it to your application's middleware.\n  ```javascript\n  const helmet = require(\"helmet\");\n  app.use(helmet());\n  ```\n\n## References\n\n- [Express Security Best Practices: Use Helmet](https://expressjs.com/en/advanced/best-practice-security.html#use-helmet)","markdown":"## Description\n\nHelmet can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately. Failing to configure Helmet for HTTP headers leaves your application vulnerable to several web attacks.\n\n## Remediations\n\n- **Do** use Helmet middleware to secure your app by adding it to your application's middleware.\n  ```javascript\n  const helmet = require(\"helmet\");\n  app.use(helmet());\n  ```\n\n## References\n\n- [Express Security Best Practices: Use Helmet](https://expressjs.com/en/advanced/best-practice-security.html#use-helmet)"}},{"id":"javascript_node_missing_tls_validation","name":"javascript_node_missing_tls_validation","shortDescription":{"text":"Missing TLS validation"},"fullDescription":{"text":"Missing TLS validation"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nFailing to validate TLS certificates exposes your application to significant security risks, including Man-in-the-Middle attacks and data interception. This vulnerability occurs when the application does not properly verify the SSL/TLS certificate of the server it is connecting to, allowing attackers to potentially intercept or alter data in transit.\n\n## Remediations\n\n- **Do not** disable SSL/TLS certificate validation. Specifically, avoid setting the `NODE_TLS_REJECT_UNAUTHORIZED` variable to zero in environments where security is a concern. This action turns off TLS/SSL certificate validation, leaving your application vulnerable to attacks.\n    ```javascript\n    process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n    ```","markdown":"## Description\n\nFailing to validate TLS certificates exposes your application to significant security risks, including Man-in-the-Middle attacks and data interception. This vulnerability occurs when the application does not properly verify the SSL/TLS certificate of the server it is connecting to, allowing attackers to potentially intercept or alter data in transit.\n\n## Remediations\n\n- **Do not** disable SSL/TLS certificate validation. Specifically, avoid setting the `NODE_TLS_REJECT_UNAUTHORIZED` variable to zero in environments where security is a concern. This action turns off TLS/SSL certificate validation, leaving your application vulnerable to attacks.\n    ```javascript\n    process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n    ```"}},{"id":"java_lang_ssl_hostname_verifier","name":"java_lang_ssl_hostname_verifier","shortDescription":{"text":"Missing or permissive SSL hostname verifier"},"fullDescription":{"text":"Missing or permissive SSL hostname verifier"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIt is best security practice to always verify the hostname when establishing a SSL/TLS connection. Failure to do so exposes your application to Man-in-the-Middle attacks. This vulnerability arises when the application fails to confirm that the server's hostname matches the hostname in the server's SSL certificate.\n\n## Remediations\n\n- **Do not** use `ALLOW_ALL_HOSTNAME_VERIFIER` or any similarly permissive hostname verifiers. These verifiers do not properly check if the server's hostname matches the SSL certificate, undermining the security of your connection.\n  ```java\n  HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n  HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier); // unsafe\n  ```","markdown":"## Description\n\nIt is best security practice to always verify the hostname when establishing a SSL/TLS connection. Failure to do so exposes your application to Man-in-the-Middle attacks. This vulnerability arises when the application fails to confirm that the server's hostname matches the hostname in the server's SSL certificate.\n\n## Remediations\n\n- **Do not** use `ALLOW_ALL_HOSTNAME_VERIFIER` or any similarly permissive hostname verifiers. These verifiers do not properly check if the server's hostname matches the SSL certificate, undermining the security of your connection.\n  ```java\n  HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n  HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier); // unsafe\n  ```"}},{"id":"java_third_parties_new_relic","name":"java_third_parties_new_relic","shortDescription":{"text":"Leakage of sensitive data to New Relic"},"fullDescription":{"text":"Leakage of sensitive data to New Relic"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like New Relic is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like New Relic\n\n## References\n- [New Relic Docs](https://docs.newrelic.com/)\n- [Log obfuscation](https://docs.newrelic.com/docs/logs/ui-data/obfuscation-ui/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like New Relic is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like New Relic\n\n## References\n- [New Relic Docs](https://docs.newrelic.com/)\n- [Log obfuscation](https://docs.newrelic.com/docs/logs/ui-data/obfuscation-ui/)\n"}},{"id":"java_third_parties_elasticsearch","name":"java_third_parties_elasticsearch","shortDescription":{"text":"Leakage of sensitive data to ElasticSearch"},"fullDescription":{"text":"Leakage of sensitive data to ElasticSearch"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party data tools is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like ElasticSearch\n\n## References\n- [Elasticsearch docs](https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/index.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party data tools is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like ElasticSearch\n\n## References\n- [Elasticsearch docs](https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/index.html)\n"}},{"id":"java_lang_cookie_with_http_only_false","name":"java_lang_cookie_with_http_only_false","shortDescription":{"text":"Permissive HTTP Only option in cookie configuration"},"fullDescription":{"text":"Permissive HTTP Only option in cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaving the HTTP Only option in cookie configuration unset or false can expose your application to attacks by allowing client-side scripts to access cookie values. This vulnerability can lead to unauthorized access or exploits.\n\n## Remediations\n\n- **Do** set `HttpOnly` to `true` for cookies to prevent client-side scripts from accessing the cookie values. This step is crucial for enhancing the security of your application by limiting access to cookie data.\n  ```java\n  cookie.setHttpOnly(true);\n  ```","markdown":"## Description\n\nLeaving the HTTP Only option in cookie configuration unset or false can expose your application to attacks by allowing client-side scripts to access cookie values. This vulnerability can lead to unauthorized access or exploits.\n\n## Remediations\n\n- **Do** set `HttpOnly` to `true` for cookies to prevent client-side scripts from accessing the cookie values. This step is crucial for enhancing the security of your application by limiting access to cookie data.\n  ```java\n  cookie.setHttpOnly(true);\n  ```"}},{"id":"javascript_third_parties_google_tag_manager","name":"javascript_third_parties_google_tag_manager","shortDescription":{"text":"Leakage of sensitive data to Google Tag Manager"},"fullDescription":{"text":"Leakage of sensitive data to Google Tag Manager"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party services and tools like Google Tag Manager is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to analytics libraries like Google Analytics.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n  datalayer.push({\n    user: {\n      uuid: user.uuid\n    }\n  })\n  ```\n\n## References\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)","markdown":"## Description\n\nLeaking sensitive data to third-party services and tools like Google Tag Manager is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to analytics libraries like Google Analytics.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n  datalayer.push({\n    user: {\n      uuid: user.uuid\n    }\n  })\n  ```\n\n## References\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)"}},{"id":"javascript_lang_websocket_insecure","name":"javascript_lang_websocket_insecure","shortDescription":{"text":"Usage of insecure websocket connection"},"fullDescription":{"text":"Usage of insecure websocket connection"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour application is at risk when it connects to APIs via insecure websocket connections. This vulnerability occurs because the data transmitted over these connections can be intercepted or tampered with by attackers. Ensure that all websocket connections in your application use SSL to encrypt the data in transit, safeguarding it from unauthorized access.\n\n## Remediations\n\n- **Do not** initiate websocket connections without SSL. Such connections are vulnerable to interception and compromise.\n  ```javascript\n  const client = new WebSocket('ws://insecure-api.com'); // unsafe\n  ```\n- **Do** ensure all websocket connections are secured with SSL. This encrypts the data transmitted, protecting it from eavesdroppers and tampering.\n  ```javascript\n  const client = new WebSocket('wss://secure-api.com');\n  ```\n\n## References\n\n- [OWASP insecure transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)","markdown":"## Description\n\nYour application is at risk when it connects to APIs via insecure websocket connections. This vulnerability occurs because the data transmitted over these connections can be intercepted or tampered with by attackers. Ensure that all websocket connections in your application use SSL to encrypt the data in transit, safeguarding it from unauthorized access.\n\n## Remediations\n\n- **Do not** initiate websocket connections without SSL. Such connections are vulnerable to interception and compromise.\n  ```javascript\n  const client = new WebSocket('ws://insecure-api.com'); // unsafe\n  ```\n- **Do** ensure all websocket connections are secured with SSL. This encrypts the data transmitted, protecting it from eavesdroppers and tampering.\n  ```javascript\n  const client = new WebSocket('wss://secure-api.com');\n  ```\n\n## References\n\n- [OWASP insecure transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)"}},{"id":"javascript_express_https_protocol_missing","name":"javascript_express_https_protocol_missing","shortDescription":{"text":"Missing secure HTTP server configuration"},"fullDescription":{"text":"Missing secure HTTP server configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nFailing to configure your HTTP server to use HTTPS can expose data to interception and manipulation. HTTPS, which incorporates TLS (Transport Layer Security), encrypts data in transit and therefore provides a more secure communication channel than HTTP.\n\n## Remediations\n\n- **Do** use the `https` module for creating secure servers in your applications. This ensures that data transmitted between the server and clients is encrypted.\n  ```javascript\n  var https = require('https');\n  var express = require('express');\n  var app = express();\n\n  var httpsServer = https.createServer(app);\n  httpsServer.listen(8080);\n  ```\n\n## References\n\n- [Express Security Best Practices: use TLS](https://expressjs.com/en/advanced/best-practice-security.html#use-tls)","markdown":"## Description\n\nFailing to configure your HTTP server to use HTTPS can expose data to interception and manipulation. HTTPS, which incorporates TLS (Transport Layer Security), encrypts data in transit and therefore provides a more secure communication channel than HTTP.\n\n## Remediations\n\n- **Do** use the `https` module for creating secure servers in your applications. This ensures that data transmitted between the server and clients is encrypted.\n  ```javascript\n  var https = require('https');\n  var express = require('express');\n  var app = express();\n\n  var httpsServer = https.createServer(app);\n  httpsServer.listen(8080);\n  ```\n\n## References\n\n- [Express Security Best Practices: use TLS](https://expressjs.com/en/advanced/best-practice-security.html#use-tls)"}},{"id":"javascript_third_parties_openai","name":"javascript_third_parties_openai","shortDescription":{"text":"Leakage of sensitive data to OpenAI"},"fullDescription":{"text":"Leakage of sensitive data to OpenAI"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party services like OpenAI is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like OpenAI.\n\n## References\n- [OpenAI API docs](https://platform.openai.com/docs/api-reference/introduction)\n","markdown":"## Description\n\nLeaking sensitive data to third-party services like OpenAI is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like OpenAI.\n\n## References\n- [OpenAI API docs](https://platform.openai.com/docs/api-reference/introduction)\n"}},{"id":"java_lang_weak_password_hash_md5","name":"java_lang_weak_password_hash_md5","shortDescription":{"text":"Usage of weak hashing library on a password (MD5)"},"fullDescription":{"text":"Usage of weak hashing library on a password (MD5)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a weak hashing library like MD5 for password storage compromises security. MD5 is outdated and vulnerable, making it easier for attackers to crack passwords and gain unauthorized access.\n\n## Remediations\n\n- **Do not** use MD5 for hashing passwords or any sensitive data. It is no longer considered secure.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"MD5\"); // unsafe\n  ```\n- **Do** opt for stronger hashing algorithms such as SHA-256 to enhance the security of stored data.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)","markdown":"## Description\n\nUsing a weak hashing library like MD5 for password storage compromises security. MD5 is outdated and vulnerable, making it easier for attackers to crack passwords and gain unauthorized access.\n\n## Remediations\n\n- **Do not** use MD5 for hashing passwords or any sensitive data. It is no longer considered secure.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"MD5\"); // unsafe\n  ```\n- **Do** opt for stronger hashing algorithms such as SHA-256 to enhance the security of stored data.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)"}},{"id":"javascript_lang_os_command_injection","name":"javascript_lang_os_command_injection","shortDescription":{"text":"Unsanitized user input in OS command"},"fullDescription":{"text":"Unsanitized user input in OS command"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nExecuting operating system commands with unsanitized user input can lead to command injection vulnerabilities. This occurs when attackers manipulate the input to execute unauthorized commands, potentially gaining control over the system.\n\n## Remediations\n\n- **Do not** directly use user input in OS command execution. This can open up the system to command injection attacks.\n- **Do** use static or predefined values for command parameters when possible. This reduces the risk of injection and ensures that the command operates within expected parameters.\n  ```javascript\n  let filePattern = \"*.js\"\n\n  if (req.params.graphql) {\n    filePattern = \"*.gql\"\n  }\n\n  cp.exec(`cp ${filePattern} foo`, (error, stdout, stderr) =\u003e {});\n  ```\n- **Do** validate and sanitize all user input used in OS commands. Ensure that the input does not contain malicious characters or command sequences.\n\n## References\n\n- [OWASP command injection explained](https://owasp.org/www-community/attacks/Command_Injection)","markdown":"## Description\n\nExecuting operating system commands with unsanitized user input can lead to command injection vulnerabilities. This occurs when attackers manipulate the input to execute unauthorized commands, potentially gaining control over the system.\n\n## Remediations\n\n- **Do not** directly use user input in OS command execution. This can open up the system to command injection attacks.\n- **Do** use static or predefined values for command parameters when possible. This reduces the risk of injection and ensures that the command operates within expected parameters.\n  ```javascript\n  let filePattern = \"*.js\"\n\n  if (req.params.graphql) {\n    filePattern = \"*.gql\"\n  }\n\n  cp.exec(`cp ${filePattern} foo`, (error, stdout, stderr) =\u003e {});\n  ```\n- **Do** validate and sanitize all user input used in OS commands. Ensure that the input does not contain malicious characters or command sequences.\n\n## References\n\n- [OWASP command injection explained](https://owasp.org/www-community/attacks/Command_Injection)"}},{"id":"javascript_lang_exception","name":"javascript_lang_exception","shortDescription":{"text":"Leakage of sensitive data in exception message"},"fullDescription":{"text":"Leakage of sensitive data in exception message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeakage of sensitive data in exception messages can lead to data breaches. This vulnerability occurs when sensitive information is included in exceptions, making it accessible to unauthorized users.\n\n## Remediations\n\n- **Do not** include sensitive data in exception messages. This can inadvertently expose personal or confidential information.\n  ```javascript\n  throw new CustomError(`Error with ${user.email}`) // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers in exception messages to maintain user privacy and data security.\n  ```javascript\n  throw new CustomError(`Error with ${user.uuid}`)\n  ```","markdown":"## Description\n\nLeakage of sensitive data in exception messages can lead to data breaches. This vulnerability occurs when sensitive information is included in exceptions, making it accessible to unauthorized users.\n\n## Remediations\n\n- **Do not** include sensitive data in exception messages. This can inadvertently expose personal or confidential information.\n  ```javascript\n  throw new CustomError(`Error with ${user.email}`) // unsafe\n  ```\n- **Do** use non-sensitive, unique identifiers in exception messages to maintain user privacy and data security.\n  ```javascript\n  throw new CustomError(`Error with ${user.uuid}`)\n  ```"}},{"id":"javascript_third_parties_airbrake","name":"javascript_third_parties_airbrake","shortDescription":{"text":"Leakage of sensitive data to Airbrake"},"fullDescription":{"text":"Leakage of sensitive data to Airbrake"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Airbrake is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when logging errors or events to Airbrake\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n  airbrake.notify({\n    error: err,\n    params: { user: user.uuid },\n  });\n  ```\n\n## References\n- [Airbrake Docs](https://docs.airbrake.io/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Airbrake is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when logging errors or events to Airbrake\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n  airbrake.notify({\n    error: err,\n    params: { user: user.uuid },\n  });\n  ```\n\n## References\n- [Airbrake Docs](https://docs.airbrake.io/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n"}},{"id":"javascript_lang_session","name":"javascript_lang_session","shortDescription":{"text":"Leakage of sensitive data in local storage"},"fullDescription":{"text":"Leakage of sensitive data in local storage"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nStoring sensitive data in `localStorage` poses a security risk. This vulnerability occurs when sensitive information is saved in the browser's local storage, making it susceptible to unauthorized access.\n\n## Remediations\n\n- **Do not** store sensitive data in `localStorage`. This method exposes sensitive information to potential security threats.\n  ```javascript\n  localStorage.setItem('user', email); // unsafe\n  ```\n- **Do** use server-based session storage solutions to keep session data secure. This approach minimizes the risk of sensitive data exposure.\n- **Do** store only non-sensitive data in `localStorage`, such as a unique identifier, to reduce security risks.\n  ```javascript\n  localStorage.setItem('user', user.uuid);\n  ```\n\n## References\n\n- [OWASP sensitive data exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)","markdown":"## Description\n\nStoring sensitive data in `localStorage` poses a security risk. This vulnerability occurs when sensitive information is saved in the browser's local storage, making it susceptible to unauthorized access.\n\n## Remediations\n\n- **Do not** store sensitive data in `localStorage`. This method exposes sensitive information to potential security threats.\n  ```javascript\n  localStorage.setItem('user', email); // unsafe\n  ```\n- **Do** use server-based session storage solutions to keep session data secure. This approach minimizes the risk of sensitive data exposure.\n- **Do** store only non-sensitive data in `localStorage`, such as a unique identifier, to reduce security risks.\n  ```javascript\n  localStorage.setItem('user', user.uuid);\n  ```\n\n## References\n\n- [OWASP sensitive data exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)"}},{"id":"javascript_lang_observable_timing","name":"javascript_lang_observable_timing","shortDescription":{"text":"Observable Timing Discrepancy"},"fullDescription":{"text":"Observable Timing Discrepancy"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nObservable Timing Discrepancy occurs when the time it takes for certain operations to complete can be measured and observed by attackers. This vulnerability is particularly concerning when operations involve sensitive information, such as password checks or secret comparisons. If attackers can analyze how long these operations take, they might be able to deduce confidential details, putting your data at risk.\n\n## Remediations\n\n- **Do** implement algorithms that process sensitive information in constant time. This approach helps prevent attackers from guessing secrets based on the duration of operations.\n- **Do** use built-in security features and cryptographic libraries that offer functions safe from timing attacks for comparing secret values.\n- **Do not** use direct string comparisons for sensitive information, as this can lead to early termination of the function if a mismatch is found, revealing timing information.\n  ```javascript\n    if (apiToken === \"zDE9ET!TDq2uZx2oM!FD2\") { // unsafe\n      ...\n    }\n  ```\n- **Do not** design application logic that changes execution paths in a manner that could introduce timing discrepancies based on user input or secret values.\n\n## References\n\n- [OWASP Guide to Cryptography](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [MDN Web Docs on SubtleCrypto API](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)","markdown":"## Description\n\nObservable Timing Discrepancy occurs when the time it takes for certain operations to complete can be measured and observed by attackers. This vulnerability is particularly concerning when operations involve sensitive information, such as password checks or secret comparisons. If attackers can analyze how long these operations take, they might be able to deduce confidential details, putting your data at risk.\n\n## Remediations\n\n- **Do** implement algorithms that process sensitive information in constant time. This approach helps prevent attackers from guessing secrets based on the duration of operations.\n- **Do** use built-in security features and cryptographic libraries that offer functions safe from timing attacks for comparing secret values.\n- **Do not** use direct string comparisons for sensitive information, as this can lead to early termination of the function if a mismatch is found, revealing timing information.\n  ```javascript\n    if (apiToken === \"zDE9ET!TDq2uZx2oM!FD2\") { // unsafe\n      ...\n    }\n  ```\n- **Do not** design application logic that changes execution paths in a manner that could introduce timing discrepancies based on user input or secret values.\n\n## References\n\n- [OWASP Guide to Cryptography](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [MDN Web Docs on SubtleCrypto API](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)"}},{"id":"javascript_express_xml_external_entity_vulnerability","name":"javascript_express_xml_external_entity_vulnerability","shortDescription":{"text":"Unsanitized user input in XML parsing method"},"fullDescription":{"text":"Unsanitized user input in XML parsing method"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUnsanitized user input in XML parsing can lead to XML External Entity (XXE) injection. This vulnerability occurs when XML input containing a reference to an external entity is processed by an XML parser. The external entity can point to a file URI or network resource, potentially allowing an attacker to access sensitive data or interact with internal systems.\n\n## Remediations\n\n- **Do not** parse XML input containing untrusted data without proper sanitization. External entities within the XML should be treated with caution.\n  ```javascript\n  var libxml = require(\"libxmljs\");\n  libxml.parseXmlString(xml, { noent: false, noblanks: true });\n  ```\n- **Do not** enable the parsing of external entities in XML parsers. For instance, when using LibXML, ensure the `noent` option is set to `false` to prevent XXE attacks.\n\n## References\n\n- [OWASP XML External Entity (XXE) prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nUnsanitized user input in XML parsing can lead to XML External Entity (XXE) injection. This vulnerability occurs when XML input containing a reference to an external entity is processed by an XML parser. The external entity can point to a file URI or network resource, potentially allowing an attacker to access sensitive data or interact with internal systems.\n\n## Remediations\n\n- **Do not** parse XML input containing untrusted data without proper sanitization. External entities within the XML should be treated with caution.\n  ```javascript\n  var libxml = require(\"libxmljs\");\n  libxml.parseXmlString(xml, { noent: false, noblanks: true });\n  ```\n- **Do not** enable the parsing of external entities in XML parsers. For instance, when using LibXML, ensure the `noent` option is set to `false` to prevent XXE attacks.\n\n## References\n\n- [OWASP XML External Entity (XXE) prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)"}},{"id":"java_third_parties_rollbar","name":"java_third_parties_rollbar","shortDescription":{"text":"Leakage of sensitive data to RollBar"},"fullDescription":{"text":"Leakage of sensitive data to RollBar"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Rollbar is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Rollbar.\n\n## References\n- [Rollbar docs](https://docs.rollbar.com/docs/java)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Rollbar is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Rollbar.\n\n## References\n- [Rollbar docs](https://docs.rollbar.com/docs/java)\n"}},{"id":"java_lang_socket_init","name":"java_lang_socket_init","shortDescription":{"text":"Usage of naive Socket class to create SSL Socket"},"fullDescription":{"text":"Usage of naive Socket class to create SSL Socket"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing the naive Socket class to create SSL sockets compromises security. Creating SSL sockets directly with `new Socket()` lacks the advanced security features provided by `SSLSocketFactory`. `SSLSocketFactory` is designed with SSL/TLS protocols in mind, offering encryption, hostname verification, and trust manager configuration. This makes it a more secure option for creating SSL sockets.\n\n## Remediations\n\n- **Do not** use `java.net.Socket` init to directly create SSL sockets, because of its limited security capabilities.\n- **Do** utilize `SSLSocketFactory` to create SSL sockets. This method ensures the use of SSL/TLS protocols and other security enhancements.\n  ```java\n  SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n  SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(socket, host, port, true);\n  ```\n\n## References\n\n- [OWASP Transport Layer Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)","markdown":"## Description\n\nUsing the naive Socket class to create SSL sockets compromises security. Creating SSL sockets directly with `new Socket()` lacks the advanced security features provided by `SSLSocketFactory`. `SSLSocketFactory` is designed with SSL/TLS protocols in mind, offering encryption, hostname verification, and trust manager configuration. This makes it a more secure option for creating SSL sockets.\n\n## Remediations\n\n- **Do not** use `java.net.Socket` init to directly create SSL sockets, because of its limited security capabilities.\n- **Do** utilize `SSLSocketFactory` to create SSL sockets. This method ensures the use of SSL/TLS protocols and other security enhancements.\n  ```java\n  SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n  SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(socket, host, port, true);\n  ```\n\n## References\n\n- [OWASP Transport Layer Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)"}},{"id":"javascript_lang_handlebars_no_escape","name":"javascript_lang_handlebars_no_escape","shortDescription":{"text":"Missing escape of HTML entities in Handlebars template compilation"},"fullDescription":{"text":"Missing escape of HTML entities in Handlebars template compilation"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIn Handlebars (a templating engine that dynamically generates HTML markup), setting `noEscape` to true disables escaping HTML entities within the template output itself. This poses a security vulnerability, particularly leading to Cross-Site Scripting (XSS) attacks if the template content comes from an untrusted source.\n\n## Remediations\n\n- **Do** set `noEscape` to false while compiling Handlebars templates, to ensure that HTML entities are properly escaped, thus mitigating the risk of XSS vulnerabilities.\n  ```javascript\n  Handlebars.compile(template, { noEscape: false });\n  ```\n\n## References\n\n- [Handlebars compile docs](https://handlebarsjs.com/api-reference/compilation.html#handlebars-compile-template-options)\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nIn Handlebars (a templating engine that dynamically generates HTML markup), setting `noEscape` to true disables escaping HTML entities within the template output itself. This poses a security vulnerability, particularly leading to Cross-Site Scripting (XSS) attacks if the template content comes from an untrusted source.\n\n## Remediations\n\n- **Do** set `noEscape` to false while compiling Handlebars templates, to ensure that HTML entities are properly escaped, thus mitigating the risk of XSS vulnerabilities.\n  ```javascript\n  Handlebars.compile(template, { noEscape: false });\n  ```\n\n## References\n\n- [Handlebars compile docs](https://handlebarsjs.com/api-reference/compilation.html#handlebars-compile-template-options)\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)"}},{"id":"javascript_express_nosql_injection","name":"javascript_express_nosql_injection","shortDescription":{"text":"Unsanitized input in NoSQL query"},"fullDescription":{"text":"Unsanitized input in NoSQL query"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized data in NoSQL queries exposes your application to NoSQL injection attacks. This vulnerability arises when user input, request data, or any externally influenced data is directly passed into a NoSQL query function without proper sanitization.\n\n## Remediations\n\n- **Do not** include raw, unsanitized user input in NoSQL queries. This practice can lead to NoSQL injection vulnerabilities.\n  ```javascript\n    const User = require(\"../models/user\")\n    const newUser = new User(req.body); // unsafe\n  ```\n- **Do** sanitize all input data before using it in NoSQL queries. Ensuring data is properly sanitized can prevent NoSQL injection attacks.\n  ```javascript\n    const User = require(\"../models/user\");\n\n    username = req.params.username;\n    User.findOne({ name: username.toString() });\n  ```\n\n## References\n\n- [OWASP NoSQL injection explained](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection)\n","markdown":"## Description\n\nUsing unsanitized data in NoSQL queries exposes your application to NoSQL injection attacks. This vulnerability arises when user input, request data, or any externally influenced data is directly passed into a NoSQL query function without proper sanitization.\n\n## Remediations\n\n- **Do not** include raw, unsanitized user input in NoSQL queries. This practice can lead to NoSQL injection vulnerabilities.\n  ```javascript\n    const User = require(\"../models/user\")\n    const newUser = new User(req.body); // unsafe\n  ```\n- **Do** sanitize all input data before using it in NoSQL queries. Ensuring data is properly sanitized can prevent NoSQL injection attacks.\n  ```javascript\n    const User = require(\"../models/user\");\n\n    username = req.params.username;\n    User.findOne({ name: username.toString() });\n  ```\n\n## References\n\n- [OWASP NoSQL injection explained](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection)\n"}},{"id":"javascript_lang_dynamic_regex","name":"javascript_lang_dynamic_regex","shortDescription":{"text":"Unsanitized dynamic input in regular expression"},"fullDescription":{"text":"Unsanitized dynamic input in regular expression"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nCreating regular expressions from dynamic input can lead to a vulnerability known as Regular Expression Denial of Service (ReDoS). This issue arises because some regular expressions can be processed with exponential time complexity. When attackers exploit this, it can significantly drain CPU resources, effectively causing a denial of service.\n\n## Remediations\n\n- **Do** validate all dynamic and user-supplied input against a strict safelist of allowed characters before using it in regular expressions. This step helps prevent attackers from injecting malicious patterns.\n- **Do** restrict the length of input that can be processed. Limiting input size is a straightforward way to mitigate many ReDoS vulnerabilities.\n- **Do** implement timeouts for regular expression evaluation to avoid excessive resource consumption. This can be achieved using JavaScript environments or libraries that allow setting execution time limits.\n- **Do** simplify complex regular expressions to reduce the risk of catastrophic backtracking. Breaking down expressions into simpler parts makes them safer and more manageable.\n- **Do not** directly concatenate user input into regular expressions. This practice can introduce unsafe patterns and lead to vulnerabilities.\n  ```javascript\n  var dynamicRegex = new RegExp('^' + userInput); // unsafe\n  ```\n\n## References\n\n- [OWASP Regular expression Denial of Service - ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)","markdown":"## Description\n\nCreating regular expressions from dynamic input can lead to a vulnerability known as Regular Expression Denial of Service (ReDoS). This issue arises because some regular expressions can be processed with exponential time complexity. When attackers exploit this, it can significantly drain CPU resources, effectively causing a denial of service.\n\n## Remediations\n\n- **Do** validate all dynamic and user-supplied input against a strict safelist of allowed characters before using it in regular expressions. This step helps prevent attackers from injecting malicious patterns.\n- **Do** restrict the length of input that can be processed. Limiting input size is a straightforward way to mitigate many ReDoS vulnerabilities.\n- **Do** implement timeouts for regular expression evaluation to avoid excessive resource consumption. This can be achieved using JavaScript environments or libraries that allow setting execution time limits.\n- **Do** simplify complex regular expressions to reduce the risk of catastrophic backtracking. Breaking down expressions into simpler parts makes them safer and more manageable.\n- **Do not** directly concatenate user input into regular expressions. This practice can introduce unsafe patterns and lead to vulnerabilities.\n  ```javascript\n  var dynamicRegex = new RegExp('^' + userInput); // unsafe\n  ```\n\n## References\n\n- [OWASP Regular expression Denial of Service - ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)"}},{"id":"java_lang_sqli","name":"java_lang_sqli","shortDescription":{"text":"Unsanitized external input in SQL query"},"fullDescription":{"text":"Unsanitized external input in SQL query"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized data, such as user input or request data, or externally influenced data passed to a function, in SQL query exposes your application to SQL injection attacks. This vulnerability arises when externally controlled data is directly included in SQL statements without proper sanitation, allowing attackers to manipulate queries and access or modify data.\n\n## Remediations\n\n- **Do not** include unsanitized input in SQL queries. This practice can lead to SQL injection vulnerabilities.\n  ```java\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(\"select name from users where id='\" + uri.getQueryParameter(\"user_id\") + \"'\"));\n  ```\n- **Do** use prepared statements for SQL queries to safely include external input.\n  ```java\n  PreparedStatement myStmt = myCon.prepareStatement(\"select * from students where age \u003e ? and name = ?\");\n  myStmt.setInt(1, uri.getQueryParameter(\"age\"));\n  myStmt.setString(2, uri.getQueryParameter(\"name\"));\n  ```\n\n## References\n\n- [OWASP SQL injection explained](https://owasp.org/www-community/attacks/SQL_Injection)\n- [OWASP SQL injection prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized data, such as user input or request data, or externally influenced data passed to a function, in SQL query exposes your application to SQL injection attacks. This vulnerability arises when externally controlled data is directly included in SQL statements without proper sanitation, allowing attackers to manipulate queries and access or modify data.\n\n## Remediations\n\n- **Do not** include unsanitized input in SQL queries. This practice can lead to SQL injection vulnerabilities.\n  ```java\n  Statement stmt = conn.createStatement();\n  ResultSet rs = stmt.executeQuery(\"select name from users where id='\" + uri.getQueryParameter(\"user_id\") + \"'\"));\n  ```\n- **Do** use prepared statements for SQL queries to safely include external input.\n  ```java\n  PreparedStatement myStmt = myCon.prepareStatement(\"select * from students where age \u003e ? and name = ?\");\n  myStmt.setInt(1, uri.getQueryParameter(\"age\"));\n  myStmt.setString(2, uri.getQueryParameter(\"name\"));\n  ```\n\n## References\n\n- [OWASP SQL injection explained](https://owasp.org/www-community/attacks/SQL_Injection)\n- [OWASP SQL injection prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)"}},{"id":"java_android_prevent_screenshot","name":"java_android_prevent_screenshot","shortDescription":{"text":"Permissive screenshot option set"},"fullDescription":{"text":"Permissive screenshot option set"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe Android operating system can capture screenshots of the current application view, such as when the app is minimized. This capability is controlled by the FLAG_SECURE option. If FLAG_SECURE is not enabled, Android can take screenshots, which might include sensitive information.\n\n## Remediations\n\n- **Do** set the FLAG_SECURE option to true in your Android application to prevent the system from taking screenshots of your app's activities. This is crucial for protecting potentially sensitive information from being captured and stored in screenshots.\n  ```java\n  getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);\n  ```","markdown":"## Description\n\nThe Android operating system can capture screenshots of the current application view, such as when the app is minimized. This capability is controlled by the FLAG_SECURE option. If FLAG_SECURE is not enabled, Android can take screenshots, which might include sensitive information.\n\n## Remediations\n\n- **Do** set the FLAG_SECURE option to true in your Android application to prevent the system from taking screenshots of your app's activities. This is crucial for protecting potentially sensitive information from being captured and stored in screenshots.\n  ```java\n  getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);\n  ```"}},{"id":"java_lang_path_using_user_input","name":"java_lang_path_using_user_input","shortDescription":{"text":"Unsanitized user input in file path"},"fullDescription":{"text":"Unsanitized user input in file path"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUnsanitized user input in file path resolution can lead to security vulnerabilities. This issue arises when an application directly uses input from the user to determine file paths or names without proper validation or sanitization. Attackers can exploit this to access unauthorized files or directories, leading to data breaches or other security compromises.\n\n## Remediations\n\n- **Do not** directly use user input in file paths without sanitization. This prevents attackers from manipulating file paths to access or manipulate unauthorized files.\n- **Do** use a safelist to define accessible paths or directories. Only allow user input to influence file paths within these predefined, safe boundaries.\n- **Do** sanitize user input used in file path resolution. For example, use methods like `FilenameUtils.getName()` to safely extract only the intended file name from the user input, removing any path manipulation attempts.\n  ```java\n  public class Cls extends HttpServlet\n  {\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String image = request.getParameter(\"user_profile_picture\");\n          File file = new File(\"user/profile/\" + FilenameUtils.getName(image));\n      }\n  }\n  ```","markdown":"## Description\n\nUnsanitized user input in file path resolution can lead to security vulnerabilities. This issue arises when an application directly uses input from the user to determine file paths or names without proper validation or sanitization. Attackers can exploit this to access unauthorized files or directories, leading to data breaches or other security compromises.\n\n## Remediations\n\n- **Do not** directly use user input in file paths without sanitization. This prevents attackers from manipulating file paths to access or manipulate unauthorized files.\n- **Do** use a safelist to define accessible paths or directories. Only allow user input to influence file paths within these predefined, safe boundaries.\n- **Do** sanitize user input used in file path resolution. For example, use methods like `FilenameUtils.getName()` to safely extract only the intended file name from the user input, removing any path manipulation attempts.\n  ```java\n  public class Cls extends HttpServlet\n  {\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String image = request.getParameter(\"user_profile_picture\");\n          File file = new File(\"user/profile/\" + FilenameUtils.getName(image));\n      }\n  }\n  ```"}},{"id":"java_lang_file_permission_others","name":"java_lang_file_permission_others","shortDescription":{"text":"Usage of permissive file permission ('other')"},"fullDescription":{"text":"Usage of permissive file permission ('other')"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nGranting overly permissive file permissions, especially to 'other', poses a significant security risk by potentially exposing sensitive information to unauthorized users.\n\n## Remediations\n\n- **Do** keep file permissions as restrictive as necessary. Opt for granting privileges to 'groups' rather than 'other' to minimize the risk of unauthorized access.\n  ```java\n  permissions.add(PosixFilePermission.GROUP_WRITE)\n  ```\n\n## References\n\n- [Java Files class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/Files.html)\n- [Java PosixFilePermission enum](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/attribute/PosixFilePermission.html)","markdown":"## Description\n\nGranting overly permissive file permissions, especially to 'other', poses a significant security risk by potentially exposing sensitive information to unauthorized users.\n\n## Remediations\n\n- **Do** keep file permissions as restrictive as necessary. Opt for granting privileges to 'groups' rather than 'other' to minimize the risk of unauthorized access.\n  ```java\n  permissions.add(PosixFilePermission.GROUP_WRITE)\n  ```\n\n## References\n\n- [Java Files class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/Files.html)\n- [Java PosixFilePermission enum](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/attribute/PosixFilePermission.html)"}},{"id":"javascript_lang_dangerous_insert_html","name":"javascript_lang_dangerous_insert_html","shortDescription":{"text":"Unsanitized user input in dynamic HTML insertion (XSS)"},"fullDescription":{"text":"Unsanitized user input in dynamic HTML insertion (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUnsanitized user input in dynamic HTML insertion can lead to Cross-Site Scripting (XSS) attacks. This vulnerability arises when user-provided data is directly inserted into the DOM without proper sanitization, potentially allowing attackers to execute malicious scripts.\n\n## Remediations\n\n- **Do** use an HTML sanitization library to clean user input before inserting it into the HTML. This step helps prevent XSS attacks by removing or neutralizing any potentially harmful scripts.\n  ```javascript\n  import sanitizeHtml from 'sanitize-html';\n\n  const html = `\u003cstrong\u003e${user.Input}\u003c/strong\u003e`;\n  document.body.innerHTML = sanitizeHtml(html);\n  ```\n\n## References\n\n- [OWASP XSS explained](https://owasp.org/www-community/attacks/xss/)","markdown":"## Description\n\nUnsanitized user input in dynamic HTML insertion can lead to Cross-Site Scripting (XSS) attacks. This vulnerability arises when user-provided data is directly inserted into the DOM without proper sanitization, potentially allowing attackers to execute malicious scripts.\n\n## Remediations\n\n- **Do** use an HTML sanitization library to clean user input before inserting it into the HTML. This step helps prevent XSS attacks by removing or neutralizing any potentially harmful scripts.\n  ```javascript\n  import sanitizeHtml from 'sanitize-html';\n\n  const html = `\u003cstrong\u003e${user.Input}\u003c/strong\u003e`;\n  document.body.innerHTML = sanitizeHtml(html);\n  ```\n\n## References\n\n- [OWASP XSS explained](https://owasp.org/www-community/attacks/xss/)"}},{"id":"java_lang_missing_database_authentication","name":"java_lang_missing_database_authentication","shortDescription":{"text":"Missing authentication for database"},"fullDescription":{"text":"Missing authentication for database"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour database is at high risk if it lacks proper authentication mechanisms. This vulnerability makes it an easy target for unauthorized access and potential security breaches.\n\n## Remediations\n\n- **Do** configure your database server with recommended authentication configuration, including a strong password and username.\n- **Do** implement a key management system to securely manage and store your passwords.\n\n## References\n\n- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)","markdown":"## Description\n\nYour database is at high risk if it lacks proper authentication mechanisms. This vulnerability makes it an easy target for unauthorized access and potential security breaches.\n\n## Remediations\n\n- **Do** configure your database server with recommended authentication configuration, including a strong password and username.\n- **Do** implement a key management system to securely manage and store your passwords.\n\n## References\n\n- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)"}},{"id":"java_lang_observable_timing","name":"java_lang_observable_timing","shortDescription":{"text":"Observable Timing Discrepancy"},"fullDescription":{"text":"Observable Timing Discrepancy"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nObservable Timing Discrepancy occurs when the time it takes for certain operations to complete can be measured and observed by attackers. This vulnerability is particularly concerning when operations involve sensitive information, such as password checks or secret comparisons. If attackers can analyze how long these operations take, they might be able to deduce confidential details, putting your data at risk.\n\n## Remediations\n\n- **Do** implement algorithms that process sensitive information in constant time. This approach helps prevent attackers from guessing secrets based on the duration of operations.\n- **Do** use built-in security features and cryptographic libraries that offer functions safe from timing attacks for comparing secret values.\n- **Do not** use direct string comparisons for sensitive information, as this can lead to early termination of the function if a mismatch is found, revealing timing information.\n  ```java\n    boolean isAdmin = \"admin\".equals(username); // unsafe\n  ```\n- **Do not** design application logic that changes execution paths in a manner that could introduce timing discrepancies based on user input or secret values.\n\n## References\n\n- [OWASP Guide to Cryptography](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)","markdown":"## Description\n\nObservable Timing Discrepancy occurs when the time it takes for certain operations to complete can be measured and observed by attackers. This vulnerability is particularly concerning when operations involve sensitive information, such as password checks or secret comparisons. If attackers can analyze how long these operations take, they might be able to deduce confidential details, putting your data at risk.\n\n## Remediations\n\n- **Do** implement algorithms that process sensitive information in constant time. This approach helps prevent attackers from guessing secrets based on the duration of operations.\n- **Do** use built-in security features and cryptographic libraries that offer functions safe from timing attacks for comparing secret values.\n- **Do not** use direct string comparisons for sensitive information, as this can lead to early termination of the function if a mismatch is found, revealing timing information.\n  ```java\n    boolean isAdmin = \"admin\".equals(username); // unsafe\n  ```\n- **Do not** design application logic that changes execution paths in a manner that could introduce timing discrepancies based on user input or secret values.\n\n## References\n\n- [OWASP Guide to Cryptography](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)"}},{"id":"java_third_parties_airbrake_javabrake","name":"java_third_parties_airbrake_javabrake","shortDescription":{"text":"Leakage of sensitive data to Airbrake"},"fullDescription":{"text":"Leakage of sensitive data to Airbrake"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Airbrake is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when logging errors or events to Airbrake\n\n## References\n- [Airbrake Docs](https://docs.airbrake.io/docs/platforms/java/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Airbrake is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when logging errors or events to Airbrake\n\n## References\n- [Airbrake Docs](https://docs.airbrake.io/docs/platforms/java/)\n"}},{"id":"javascript_third_parties_marked","name":"javascript_third_parties_marked","shortDescription":{"text":"Usage of vulnerable marked package"},"fullDescription":{"text":"Usage of vulnerable marked package"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nFor versions of marked less than 2.0.0, there is a Regular expression Denial of Service (ReDoS) vulnerability.\n\n## Remediations\n\n- **Do** upgrade marked to version 2.0.0 or greater.\n\n## References\n- [Vulnerability explained](https://nvd.nist.gov/vuln/detail/CVE-2021-21306)\n","markdown":"## Description\n\nFor versions of marked less than 2.0.0, there is a Regular expression Denial of Service (ReDoS) vulnerability.\n\n## Remediations\n\n- **Do** upgrade marked to version 2.0.0 or greater.\n\n## References\n- [Vulnerability explained](https://nvd.nist.gov/vuln/detail/CVE-2021-21306)\n"}},{"id":"java_lang_weak_password_encryption_des","name":"java_lang_weak_password_encryption_des","shortDescription":{"text":"Usage of weak encryption algorithm on a password (DES)"},"fullDescription":{"text":"Usage of weak encryption algorithm on a password (DES)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe Data Encryption Standard (DES) is recognized as a weak encryption algorithm and should not be used for securing passwords. Encryption, being reversible, is not suitable for password storage because it allows the original password to be retrieved. Passwords should instead be hashed, an irreversible process that transforms them into a fixed-size string of characters.\n\n## Remediations\n\n- **Do not** use DES or any encryption method for password storage. Encryption's reversible nature poses a security risk by potentially allowing the retrieval of the original password.\n- **Do** use a secure and recommended hashing algorithm for password storage. Hashing is a one-way process, making it impossible to reverse-engineer the original password from the hash. The following code snippet demonstrates how to use the SHA-256 hashing algorithm, which is considered secure for password hashing.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)","markdown":"## Description\n\nThe Data Encryption Standard (DES) is recognized as a weak encryption algorithm and should not be used for securing passwords. Encryption, being reversible, is not suitable for password storage because it allows the original password to be retrieved. Passwords should instead be hashed, an irreversible process that transforms them into a fixed-size string of characters.\n\n## Remediations\n\n- **Do not** use DES or any encryption method for password storage. Encryption's reversible nature poses a security risk by potentially allowing the retrieval of the original password.\n- **Do** use a secure and recommended hashing algorithm for password storage. Hashing is a one-way process, making it impossible to reverse-engineer the original password from the hash. The following code snippet demonstrates how to use the SHA-256 hashing algorithm, which is considered secure for password hashing.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)"}},{"id":"java_lang_padding_oracle_encryption_vulnerability","name":"java_lang_padding_oracle_encryption_vulnerability","shortDescription":{"text":"Usage of CBC (Cipher Block Chaining) mode with padding"},"fullDescription":{"text":"Usage of CBC (Cipher Block Chaining) mode with padding"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a block cipher algorithm mode, such as CBC (Cipher Block Chaining), together with a padding scheme is vulnerable to Padding Oracle attacks. This vulnerability arises because attackers can exploit the padding scheme to decrypt messages.\n\n## Remediations\n\n- **Do not** use CBC mode with padding for encryption. This combination is susceptible to security breaches.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // unsafe\n  ```\n- **Do** opt for GCM (Galois/Counter Mode) when implementing encryption. GCM is a more secure alternative that mitigates the risks associated with CBC mode.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/GCM/PKCS5Padding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)\n- [Java Security Standard Algorithm Names](https://docs.oracle.com/en/java/javase/20/docs/specs/security/standard-names.html)","markdown":"## Description\n\nUsing a block cipher algorithm mode, such as CBC (Cipher Block Chaining), together with a padding scheme is vulnerable to Padding Oracle attacks. This vulnerability arises because attackers can exploit the padding scheme to decrypt messages.\n\n## Remediations\n\n- **Do not** use CBC mode with padding for encryption. This combination is susceptible to security breaches.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // unsafe\n  ```\n- **Do** opt for GCM (Galois/Counter Mode) when implementing encryption. GCM is a more secure alternative that mitigates the risks associated with CBC mode.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/GCM/PKCS5Padding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)\n- [Java Security Standard Algorithm Names](https://docs.oracle.com/en/java/javase/20/docs/specs/security/standard-names.html)"}},{"id":"javascript_lang_jwt_hardcoded_secret","name":"javascript_lang_jwt_hardcoded_secret","shortDescription":{"text":"Leakage of hard-coded secret in JWT"},"fullDescription":{"text":"Leakage of hard-coded secret in JWT"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nStoring hard-coded secrets in your code, especially for JSON Web Tokens (JWT), poses a significant security risk. This practice makes your application vulnerable to unauthorized access and attacks.\n\n## Remediations\n\n- **Do not** hard-code secrets in your code. Hard-coding makes sensitive information easily accessible to anyone who can view the code.\n- **Do** use environment variables to store sensitive information such as secrets. This method keeps credentials out of your codebase and makes them easier to manage securely.\n```javascript\n  var jwt = require(\"jsonwebtoken\");\n  var token = jwt.sign({ foo: \"bar\" }, process.env.JWT_SECRET);\n```\n- **Do** consider implementing a key-management system to securely handle secrets and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)","markdown":"## Description\n\nStoring hard-coded secrets in your code, especially for JSON Web Tokens (JWT), poses a significant security risk. This practice makes your application vulnerable to unauthorized access and attacks.\n\n## Remediations\n\n- **Do not** hard-code secrets in your code. Hard-coding makes sensitive information easily accessible to anyone who can view the code.\n- **Do** use environment variables to store sensitive information such as secrets. This method keeps credentials out of your codebase and makes them easier to manage securely.\n```javascript\n  var jwt = require(\"jsonwebtoken\");\n  var token = jwt.sign({ foo: \"bar\" }, process.env.JWT_SECRET);\n```\n- **Do** consider implementing a key-management system to securely handle secrets and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)"}},{"id":"javascript_lang_sql_injection","name":"javascript_lang_sql_injection","shortDescription":{"text":"Unsanitized input in SQL query"},"fullDescription":{"text":"Unsanitized input in SQL query"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized data, such as user input or request data, or externally influenced data passed to a function, in SQL query exposes your application to SQL injection attacks. This vulnerability arises when externally controlled data is directly included in SQL statements without proper sanitation, allowing attackers to manipulate queries and access or modify data.\n\n## Remediations\n\n- **Do not** use raw SQL queries that concatenate unsanitized input directly.\n  ```javascript\n  var sqlite = new Sequelize(\"sqlite::memory:\");\n  sqlite.query(\"SELECT * FROM users WHERE ID = \" + req.params.userId); // unsafe\n  ```\n- **Do** validate all query inputs to ensure they meet expected patterns or values before using them in a query.\n  ```javascript\n  var rawId = req.params.userId\n  if !(/[0-9]+/.test(rawId)) {\n    // input is unexpected; don't make the query\n  }\n  ```\n- **Do** use prepared (or parameterized) statements for querying databases to safely include external input.\n  ```javascript\n  var sqlite = new Sequelize(\"sqlite::memory:\");\n  sqlite.query(\n    \"SELECT * FROM users WHERE ID = ?\",\n    { replacements: [req.params.userId] },\n    type: sequelize.QueryTypes.SELECT\n  )\n  ```\n\n## References\n\n- [OWASP SQL injection explained](https://owasp.org/www-community/attacks/SQL_Injection)\n- [OWASP SQL injection prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized data, such as user input or request data, or externally influenced data passed to a function, in SQL query exposes your application to SQL injection attacks. This vulnerability arises when externally controlled data is directly included in SQL statements without proper sanitation, allowing attackers to manipulate queries and access or modify data.\n\n## Remediations\n\n- **Do not** use raw SQL queries that concatenate unsanitized input directly.\n  ```javascript\n  var sqlite = new Sequelize(\"sqlite::memory:\");\n  sqlite.query(\"SELECT * FROM users WHERE ID = \" + req.params.userId); // unsafe\n  ```\n- **Do** validate all query inputs to ensure they meet expected patterns or values before using them in a query.\n  ```javascript\n  var rawId = req.params.userId\n  if !(/[0-9]+/.test(rawId)) {\n    // input is unexpected; don't make the query\n  }\n  ```\n- **Do** use prepared (or parameterized) statements for querying databases to safely include external input.\n  ```javascript\n  var sqlite = new Sequelize(\"sqlite::memory:\");\n  sqlite.query(\n    \"SELECT * FROM users WHERE ID = ?\",\n    { replacements: [req.params.userId] },\n    type: sequelize.QueryTypes.SELECT\n  )\n  ```\n\n## References\n\n- [OWASP SQL injection explained](https://owasp.org/www-community/attacks/SQL_Injection)\n- [OWASP SQL injection prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)"}},{"id":"javascript_third_parties_rollbar","name":"javascript_third_parties_rollbar","shortDescription":{"text":"Leakage of sensitive data to RollBar"},"fullDescription":{"text":"Leakage of sensitive data to RollBar"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Rollbar is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Rollbar.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    Rollbar.critical(\"Connection error from remote Payments API\", user.uuid);\n  ```\n\n## References\n- [Rollbar docs](https://docs.rollbar.com/docs/javascript)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Rollbar is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Rollbar.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    Rollbar.critical(\"Connection error from remote Payments API\", user.uuid);\n  ```\n\n## References\n- [Rollbar docs](https://docs.rollbar.com/docs/javascript)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n"}},{"id":"javascript_lang_path_traversal","name":"javascript_lang_path_traversal","shortDescription":{"text":"Unsanitized dynamic input in file path"},"fullDescription":{"text":"Unsanitized dynamic input in file path"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized dynamic input to determine file paths can allow attackers to gain access to files and folders outside of the intended scope. This vulnerability occurs when input provided by users is directly used to access the filesystem without proper validation or sanitization.\n\n## Remediations\n\n- **Do not** directly use user input to construct file paths. This can lead to unauthorized file access.\n- **Do** sanitize user input used in file paths. Replace patterns that can navigate out of intended directories, such as `..\\..`, to prevent path traversal attacks.\n  ```javascript\n  var folder = target.replace(/^(\\.\\.(\\/|\\\\|$))+/, '');\n  ```\n- **Do** check for and remove any instances of the NULL byte (\"%00\") in user input to guard against poison NULL byte attacks.\n  ```javascript\n  if (target.indexOf('\\0') !== -1) {\n    // Handle or reject the input\n  }\n  ```\n- **Do** use path concatenation methods provided by your programming environment to securely combine user input with your base directory path. This ensures the final path starts within the intended scope.\n  ```javascript\n  const path = require(\"path\");\n  var pathname = path.join(\"/public/\", folder);\n  if (pathname.indexOf(\"/public/\") !== 0) {\n    // Handle or reject the input\n  }\n  ```\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)","markdown":"## Description\n\nUsing unsanitized dynamic input to determine file paths can allow attackers to gain access to files and folders outside of the intended scope. This vulnerability occurs when input provided by users is directly used to access the filesystem without proper validation or sanitization.\n\n## Remediations\n\n- **Do not** directly use user input to construct file paths. This can lead to unauthorized file access.\n- **Do** sanitize user input used in file paths. Replace patterns that can navigate out of intended directories, such as `..\\..`, to prevent path traversal attacks.\n  ```javascript\n  var folder = target.replace(/^(\\.\\.(\\/|\\\\|$))+/, '');\n  ```\n- **Do** check for and remove any instances of the NULL byte (\"%00\") in user input to guard against poison NULL byte attacks.\n  ```javascript\n  if (target.indexOf('\\0') !== -1) {\n    // Handle or reject the input\n  }\n  ```\n- **Do** use path concatenation methods provided by your programming environment to securely combine user input with your base directory path. This ensures the final path starts within the intended scope.\n  ```javascript\n  const path = require(\"path\");\n  var pathname = path.join(\"/public/\", folder);\n  if (pathname.indexOf(\"/public/\") !== 0) {\n    // Handle or reject the input\n  }\n  ```\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)"}},{"id":"javascript_lang_raw_html_using_user_input","name":"javascript_lang_raw_html_using_user_input","shortDescription":{"text":"Unsanitized user input in raw HTML strings (XSS)"},"fullDescription":{"text":"Unsanitized user input in raw HTML strings (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncluding unsanitized user input in HTML exposes your application to cross-site scripting (XSS) attacks. This vulnerability allows attackers to inject malicious scripts into web pages viewed by other users.\n\n## Remediations\n\n- **Do not** include user input directly in HTML strings. This practice can lead to XSS vulnerabilities.\n  ```javascript\n  const html = `\u003ch1\u003e${req.params.title}\u003c/h1\u003e` // unsafe\n  ```\n- **Do** use a framework or templating language that automatically handles the encoding and sanitization of user input when constructing HTML. This approach minimizes the risk of XSS attacks.\n- **Do** sanitize user input if you must use HTML strings directly. Utilize libraries designed for input sanitization to ensure that user input does not contain malicious content.\n  ```javascript\n  import sanitizeHtml from 'sanitize-html'\n\n  const sanitizedTitle = sanitizeHtml(req.params.title)\n  const html = `\u003ch1\u003e${sanitizedTitle}\u003c/h1\u003e`\n  ```\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nIncluding unsanitized user input in HTML exposes your application to cross-site scripting (XSS) attacks. This vulnerability allows attackers to inject malicious scripts into web pages viewed by other users.\n\n## Remediations\n\n- **Do not** include user input directly in HTML strings. This practice can lead to XSS vulnerabilities.\n  ```javascript\n  const html = `\u003ch1\u003e${req.params.title}\u003c/h1\u003e` // unsafe\n  ```\n- **Do** use a framework or templating language that automatically handles the encoding and sanitization of user input when constructing HTML. This approach minimizes the risk of XSS attacks.\n- **Do** sanitize user input if you must use HTML strings directly. Utilize libraries designed for input sanitization to ensure that user input does not contain malicious content.\n  ```javascript\n  import sanitizeHtml from 'sanitize-html'\n\n  const sanitizedTitle = sanitizeHtml(req.params.title)\n  const html = `\u003ch1\u003e${sanitizedTitle}\u003c/h1\u003e`\n  ```\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)"}},{"id":"javascript_hapi_open_redirect","name":"javascript_hapi_open_redirect","shortDescription":{"text":"Unsanitized user input in redirect"},"fullDescription":{"text":"Unsanitized user input in redirect"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input for redirects can make your application vulnerable to phishing attacks. This occurs when user input directly influences the destination of a redirect without any validation, potentially leading to malicious sites.\n\n## Remediations\n\n- **Do not** use unsanitized user input to construct URLs for redirects. This practice can inadvertently lead to phishing attacks.\n- **Do** validate user input by employing a safelist or predefined mapping for URL construction. This ensures that redirects only lead to safe and intended destinations.\n  ```javascript\n  var map = {\n    \"1\": \"/planes\",\n    \"2\": \"/trains\",\n    \"3\": \"/automobiles\",\n  }\n\n  res.redirect(map[req.body.transport])\n  ```\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized user input for redirects can make your application vulnerable to phishing attacks. This occurs when user input directly influences the destination of a redirect without any validation, potentially leading to malicious sites.\n\n## Remediations\n\n- **Do not** use unsanitized user input to construct URLs for redirects. This practice can inadvertently lead to phishing attacks.\n- **Do** validate user input by employing a safelist or predefined mapping for URL construction. This ensures that redirects only lead to safe and intended destinations.\n  ```javascript\n  var map = {\n    \"1\": \"/planes\",\n    \"2\": \"/trains\",\n    \"3\": \"/automobiles\",\n  }\n\n  res.redirect(map[req.body.transport])\n  ```\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)"}},{"id":"javascript_lang_insufficiently_random_values","name":"javascript_lang_insufficiently_random_values","shortDescription":{"text":"Usage of insufficient random value"},"fullDescription":{"text":"Usage of insufficient random value"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing predictable random values compromises your application's security, particularly if these values serve security-related functions.\n\n## Remediations\n\n- **Do** use a robust library for generating random values to enhance security.\n  ```javascript\n  const crypto = require('crypto');\n  crypto.randomBytes(16).toString('hex');\n  ```","markdown":"## Description\n\nUsing predictable random values compromises your application's security, particularly if these values serve security-related functions.\n\n## Remediations\n\n- **Do** use a robust library for generating random values to enhance security.\n  ```javascript\n  const crypto = require('crypto');\n  crypto.randomBytes(16).toString('hex');\n  ```"}},{"id":"javascript_express_ui_redress","name":"javascript_express_ui_redress","shortDescription":{"text":"Unsanitized user input in UI"},"fullDescription":{"text":"Unsanitized user input in UI"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncorporating unsanitized user input to configure X-Frame-Options or Content-Security-Policy HTTP headers exposes your application to UI redress attacks, commonly known as clickjacking. This vulnerability arises when attackers manipulate the appearance of a webpage to deceive users into performing unintended actions.\n\n## Remediations\n\n- **Do** set the most secure values for these headers to enhance protection against clickjacking.\n  ```javascript\n  res.set('X-Frame-Options', 'DENY');\n  res.set('Content-Security-Policy', \"frame-ancestors 'none'\");\n  ```\n- **Do not** directly use user input to set these headers. Instead, implement a safelist approach to ensure only approved values are used.\n  ```javascript\n  if (req.query.options === 'same') {\n    res.set('X-Frame-Options', 'SAME');\n  }\n\n  // Safelist\n  if (['deny', 'sameorigin'].includes(req.query.options.toLowerCase())) {\n    res.set('X-Frame-Options', req.query.options);\n  }\n  ```\n\n## References\n\n- [OWASP Clickjacking attack explained](https://owasp.org/www-community/attacks/Clickjacking)\n- [OWASP Clickjacking defense cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)","markdown":"## Description\n\nIncorporating unsanitized user input to configure X-Frame-Options or Content-Security-Policy HTTP headers exposes your application to UI redress attacks, commonly known as clickjacking. This vulnerability arises when attackers manipulate the appearance of a webpage to deceive users into performing unintended actions.\n\n## Remediations\n\n- **Do** set the most secure values for these headers to enhance protection against clickjacking.\n  ```javascript\n  res.set('X-Frame-Options', 'DENY');\n  res.set('Content-Security-Policy', \"frame-ancestors 'none'\");\n  ```\n- **Do not** directly use user input to set these headers. Instead, implement a safelist approach to ensure only approved values are used.\n  ```javascript\n  if (req.query.options === 'same') {\n    res.set('X-Frame-Options', 'SAME');\n  }\n\n  // Safelist\n  if (['deny', 'sameorigin'].includes(req.query.options.toLowerCase())) {\n    res.set('X-Frame-Options', req.query.options);\n  }\n  ```\n\n## References\n\n- [OWASP Clickjacking attack explained](https://owasp.org/www-community/attacks/Clickjacking)\n- [OWASP Clickjacking defense cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)"}},{"id":"javascript_express_insecure_cookie","name":"javascript_express_insecure_cookie","shortDescription":{"text":"Missing Secure option in cookie configuration"},"fullDescription":{"text":"Missing Secure option in cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nWhen a cookie lacks the Secure attribute, it can be transmitted over an unencrypted connection, making it vulnerable to interception by unauthorized parties. Enabling the Secure option ensures that cookies are only sent over HTTPS, enhancing the security of data in transit.\n\n## Remediations\n\n- **Do** set the `secure` attribute of cookies to `true`. This action mandates that cookies are sent only over HTTPS, safeguarding them from potential eavesdropping.\n  ```javascript\n  cookie({ secure: true });\n  ```\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)","markdown":"## Description\n\nWhen a cookie lacks the Secure attribute, it can be transmitted over an unencrypted connection, making it vulnerable to interception by unauthorized parties. Enabling the Secure option ensures that cookies are only sent over HTTPS, enhancing the security of data in transit.\n\n## Remediations\n\n- **Do** set the `secure` attribute of cookies to `true`. This action mandates that cookies are sent only over HTTPS, safeguarding them from potential eavesdropping.\n  ```javascript\n  cookie({ secure: true });\n  ```\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)"}},{"id":"java_lang_empty_database_password","name":"java_lang_empty_database_password","shortDescription":{"text":"Missing database password detected"},"fullDescription":{"text":"Missing database password detected"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaving a database password empty exposes its data to unauthorized access and manipulation. It's crucial to implement strong authentication measures to safeguard database content.\n\n## Remediations\n\n- **Do not** configure database servers without setting a password. This leaves the database vulnerable to unauthorized access.\n- **Do** adopt secure password management practices. Utilize a Key Management Service (KMS) to handle database passwords securely, ensuring they are not exposed in application code or configuration files.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)","markdown":"## Description\n\nLeaving a database password empty exposes its data to unauthorized access and manipulation. It's crucial to implement strong authentication measures to safeguard database content.\n\n## Remediations\n\n- **Do not** configure database servers without setting a password. This leaves the database vulnerable to unauthorized access.\n- **Do** adopt secure password management practices. Utilize a Key Management Service (KMS) to handle database passwords securely, ensuring they are not exposed in application code or configuration files.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)"}},{"id":"javascript_third_parties_open_telemetry","name":"javascript_third_parties_open_telemetry","shortDescription":{"text":"Leakage of sensitive data to OpenTelemetry"},"fullDescription":{"text":"Leakage of sensitive data to OpenTelemetry"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third parties like OpenTelemetry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third parties like OpenTelemetry.\n\n## References\n- [OpenTelemetry Docs](https://opentelemetry.io/docs/)\n","markdown":"## Description\n\nLeaking sensitive data to third parties like OpenTelemetry is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third parties like OpenTelemetry.\n\n## References\n- [OpenTelemetry Docs](https://opentelemetry.io/docs/)\n"}},{"id":"javascript_express_reduce_fingerprint","name":"javascript_express_reduce_fingerprint","shortDescription":{"text":"Missing server configuration to reduce server fingerprinting"},"fullDescription":{"text":"Missing server configuration to reduce server fingerprinting"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nReducing server fingerprinting enhances security by making it harder for attackers to identify the software your server is running. Server fingerprinting involves analyzing the unique responses of server software to specific requests, which can reveal information about the server's software and version. While not a direct security vulnerability, minimizing this information leakage is a proactive step to obscure details that could be used in targeted attacks.\n\n## Remediations\n\n- **Do** disable the `X-Powered-By` header in Express.js applications to prevent revealing the server's technology stack. Use the `app.disable()` method to achieve this.\n  ```javascript\n  app.disable('x-powered-by');\n  ```\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)","markdown":"## Description\n\nReducing server fingerprinting enhances security by making it harder for attackers to identify the software your server is running. Server fingerprinting involves analyzing the unique responses of server software to specific requests, which can reveal information about the server's software and version. While not a direct security vulnerability, minimizing this information leakage is a proactive step to obscure details that could be used in targeted attacks.\n\n## Remediations\n\n- **Do** disable the `X-Powered-By` header in Express.js applications to prevent revealing the server's technology stack. Use the `app.disable()` method to achieve this.\n  ```javascript\n  app.disable('x-powered-by');\n  ```\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)"}},{"id":"javascript_lang_format_string_using_user_input","name":"javascript_lang_format_string_using_user_input","shortDescription":{"text":"Unsanitized user input in format string"},"fullDescription":{"text":"Unsanitized user input in format string"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncluding user input directly in a format string can lead to security vulnerabilities. This issue arises when an attacker manipulates the format specifiers in the user input, resulting in misleading or fabricated messages.\n\n## Remediations\n\n- **Do not** incorporate user input directly into format strings. This approach can be exploited by attackers to manipulate output or execute malicious code.\n  ```javascript\n  console.log(`The value was ${req.params.value}`); // unsafe\n  ```\n- **Do** use a literal format string and pass user input as additional arguments. This method safely incorporates user input without exposing the application to format string vulnerabilities.\n  ```javascript\n  console.log(\"The value was %s\", req.params.value);\n  ```","markdown":"## Description\n\nIncluding user input directly in a format string can lead to security vulnerabilities. This issue arises when an attacker manipulates the format specifiers in the user input, resulting in misleading or fabricated messages.\n\n## Remediations\n\n- **Do not** incorporate user input directly into format strings. This approach can be exploited by attackers to manipulate output or execute malicious code.\n  ```javascript\n  console.log(`The value was ${req.params.value}`); // unsafe\n  ```\n- **Do** use a literal format string and pass user input as additional arguments. This method safely incorporates user input without exposing the application to format string vulnerabilities.\n  ```javascript\n  console.log(\"The value was %s\", req.params.value);\n  ```"}},{"id":"java_android_world_readable_writable_mode","name":"java_android_world_readable_writable_mode","shortDescription":{"text":"Permissive context mode for resources"},"fullDescription":{"text":"Permissive context mode for resources"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing permissive context modes like `Context.MODE_WORLD_READABLE` and `Context.MODE_WORLD_WRITEABLE` for file permissions exposes your application to significant security risks. These modes allow any application to read and write to your files, respectively. In light of these risks, these constants have been deprecated and removed from newer Android versions.\n\n## Remediations\n\n- **Do** use `Context.MODE_PRIVATE` for file permissions to ensure that your files are accessible only by your application.\n  ```java\n  getSharedPreferences(\"MyPreferences\", Context.MODE_PRIVATE);\n  ```\n- **Do** utilize a `ContentProvider` if you need to share data with other applications securely. This approach provides a granular control over who can access your data.\n  ```java\n  public class MyContentProvider extends ContentProvider {\n      // Implement content provider methods here\n  }\n  ```\n- **Do not** use `MODE_WORLD_READABLE` or `MODE_WORLD_WRITEABLE` constants, even in legacy applications. Instead, update your application to use more secure alternatives.\n\n## References\n\n- [Android Context.MODE_PRIVATE reference](https://developer.android.com/reference/android/content/Context#MODE_PRIVATE)\n- [Android Content Provider reference](https://developer.android.com/reference/android/content/ContentProvider)","markdown":"## Description\n\nUsing permissive context modes like `Context.MODE_WORLD_READABLE` and `Context.MODE_WORLD_WRITEABLE` for file permissions exposes your application to significant security risks. These modes allow any application to read and write to your files, respectively. In light of these risks, these constants have been deprecated and removed from newer Android versions.\n\n## Remediations\n\n- **Do** use `Context.MODE_PRIVATE` for file permissions to ensure that your files are accessible only by your application.\n  ```java\n  getSharedPreferences(\"MyPreferences\", Context.MODE_PRIVATE);\n  ```\n- **Do** utilize a `ContentProvider` if you need to share data with other applications securely. This approach provides a granular control over who can access your data.\n  ```java\n  public class MyContentProvider extends ContentProvider {\n      // Implement content provider methods here\n  }\n  ```\n- **Do not** use `MODE_WORLD_READABLE` or `MODE_WORLD_WRITEABLE` constants, even in legacy applications. Instead, update your application to use more secure alternatives.\n\n## References\n\n- [Android Context.MODE_PRIVATE reference](https://developer.android.com/reference/android/content/Context#MODE_PRIVATE)\n- [Android Content Provider reference](https://developer.android.com/reference/android/content/ContentProvider)"}},{"id":"java_lang_jwt_verification_bypass","name":"java_lang_jwt_verification_bypass","shortDescription":{"text":"Missing signature verification of JWT"},"fullDescription":{"text":"Missing signature verification of JWT"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nFailing to verify the signature of JSON Web Tokens (JWTs) compromises the security of an application. Signature verification is crucial for confirming the authenticity and integrity of JWTs. Without this verification, your application is open to token forgery and replay attacks, where attackers can manipulate or reuse tokens to gain unauthorized access.\n\n## Remediations\n\n- **Do not** use the `parse()` method for handling JWTs, as it does not verify the token's signature, leaving a significant security gap.\n  ```java\n  Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken); // unsafe\n  ```\n- **Do** use the `parseClaimsJws()` method when working with JWTs. This method ensures that the signature is verified, safeguarding against the manipulation of token data.\n  ```java\n  Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken);\n  ```\n\n## References\n\n- [JWT for Java Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)","markdown":"## Description\n\nFailing to verify the signature of JSON Web Tokens (JWTs) compromises the security of an application. Signature verification is crucial for confirming the authenticity and integrity of JWTs. Without this verification, your application is open to token forgery and replay attacks, where attackers can manipulate or reuse tokens to gain unauthorized access.\n\n## Remediations\n\n- **Do not** use the `parse()` method for handling JWTs, as it does not verify the token's signature, leaving a significant security gap.\n  ```java\n  Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken); // unsafe\n  ```\n- **Do** use the `parseClaimsJws()` method when working with JWTs. This method ensures that the signature is verified, safeguarding against the manipulation of token data.\n  ```java\n  Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken);\n  ```\n\n## References\n\n- [JWT for Java Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)"}},{"id":"javascript_lang_weak_password_hash_sha1","name":"javascript_lang_weak_password_hash_sha1","shortDescription":{"text":"Usage of weak hashing library on a password (SHA-1)"},"fullDescription":{"text":"Usage of weak hashing library on a password (SHA-1)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing weak hashing algorithms like SHA-1 for password storage compromises security. These algorithms are vulnerable to attacks, making it easier for attackers to crack passwords and access sensitive information.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing passwords. These algorithms are no longer considered secure due to their vulnerability to various attacks.\n- **Do** use a recommended hashing library such as Argon2id for hashing passwords. This approach enhances security by providing a more robust defense against brute-force attacks.\n  ```javascript\n  const argon2 = require(\"argon2\");\n  const hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n  ```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)","markdown":"## Description\n\nUsing weak hashing algorithms like SHA-1 for password storage compromises security. These algorithms are vulnerable to attacks, making it easier for attackers to crack passwords and access sensitive information.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing passwords. These algorithms are no longer considered secure due to their vulnerability to various attacks.\n- **Do** use a recommended hashing library such as Argon2id for hashing passwords. This approach enhances security by providing a more robust defense against brute-force attacks.\n  ```javascript\n  const argon2 = require(\"argon2\");\n  const hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n  ```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)"}},{"id":"javascript_lang_weak_password_encryption_des","name":"javascript_lang_weak_password_encryption_des","shortDescription":{"text":"Usage of weak encryption algorithm on a password (DES)"},"fullDescription":{"text":"Usage of weak encryption algorithm on a password (DES)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe Data Encryption Standard (DES) is recognized as a weak encryption algorithm and should not be used for securing passwords. Encryption, being reversible, is not suitable for password storage because it allows the original password to be retrieved. Passwords should instead be hashed, an irreversible process that transforms them into a fixed-size string of characters.\n\n## Remediations\n\n- **Do not** use DES or any encryption method for password storage. Encryption's reversible nature poses a security risk by potentially allowing the retrieval of the original password.\n- **Do** use a strong hashing algorithm like Argon2id for password storage. Hashing is one-way, making it impossible to reverse and retrieve the original password.\n  ```javascript\n  const argon2 = require(\"argon2\");\n\n  const hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n  ```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)","markdown":"## Description\n\nThe Data Encryption Standard (DES) is recognized as a weak encryption algorithm and should not be used for securing passwords. Encryption, being reversible, is not suitable for password storage because it allows the original password to be retrieved. Passwords should instead be hashed, an irreversible process that transforms them into a fixed-size string of characters.\n\n## Remediations\n\n- **Do not** use DES or any encryption method for password storage. Encryption's reversible nature poses a security risk by potentially allowing the retrieval of the original password.\n- **Do** use a strong hashing algorithm like Argon2id for password storage. Hashing is one-way, making it impossible to reverse and retrieve the original password.\n  ```javascript\n  const argon2 = require(\"argon2\");\n\n  const hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n  ```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)"}},{"id":"java_lang_cookie_missing_http_only","name":"java_lang_cookie_missing_http_only","shortDescription":{"text":"Missing HTTP Only option in cookie configuration"},"fullDescription":{"text":"Missing HTTP Only option in cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nNot setting the HTTP Only attribute to \"true\" in cookie configurations leaves the cookie vulnerable to being accessed by client-side JavaScript. This oversight can lead to the exposure of cookie values, especially on websites susceptible to Cross-Site Scripting (XSS) attacks. Enabling HTTP Only is a critical step in preventing malicious scripts from reading the cookie values through JavaScript.\n\n## Remediations\n\n- **Do** set the HTTP Only attribute to `true` for cookies to prevent them from being accessed by client-side JavaScript. This is a critical step in safeguarding your cookies against unauthorized access, especially in the context of XSS vulnerabilities.\n  ```java\n  cookie.setHttpOnly(true);\n  ```","markdown":"## Description\n\nNot setting the HTTP Only attribute to \"true\" in cookie configurations leaves the cookie vulnerable to being accessed by client-side JavaScript. This oversight can lead to the exposure of cookie values, especially on websites susceptible to Cross-Site Scripting (XSS) attacks. Enabling HTTP Only is a critical step in preventing malicious scripts from reading the cookie values through JavaScript.\n\n## Remediations\n\n- **Do** set the HTTP Only attribute to `true` for cookies to prevent them from being accessed by client-side JavaScript. This is a critical step in safeguarding your cookies against unauthorized access, especially in the context of XSS vulnerabilities.\n  ```java\n  cookie.setHttpOnly(true);\n  ```"}},{"id":"java_lang_crlf_injection","name":"java_lang_crlf_injection","shortDescription":{"text":"Possible CLRF injection detected"},"fullDescription":{"text":"Possible CLRF injection detected"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nCRLF (Carriage Return Line Feed) injection vulnerability occurs when an attacker is able to insert a sequence of line termination characters into a log message. This can lead to forged log entries, compromising the integrity of log files.\n\n## Remediations\n\n- **Do** strip any carriage return and line feed characters from user input data before logging it. This prevents attackers from injecting malicious CRLF sequences.\n  ```java\n  logger.info(userInput.replaceAll(\"[\\r\\n]+\", \"\"));\n  ```\n\n## References\n\n- [OWASP CRLF Injection](https://owasp.org/www-community/vulnerabilities/CRLF_Injection)\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)","markdown":"## Description\n\nCRLF (Carriage Return Line Feed) injection vulnerability occurs when an attacker is able to insert a sequence of line termination characters into a log message. This can lead to forged log entries, compromising the integrity of log files.\n\n## Remediations\n\n- **Do** strip any carriage return and line feed characters from user input data before logging it. This prevents attackers from injecting malicious CRLF sequences.\n  ```java\n  logger.info(userInput.replaceAll(\"[\\r\\n]+\", \"\"));\n  ```\n\n## References\n\n- [OWASP CRLF Injection](https://owasp.org/www-community/vulnerabilities/CRLF_Injection)\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)"}},{"id":"javascript_express_exposed_dir_listing","name":"javascript_express_exposed_dir_listing","shortDescription":{"text":"Missing access restriction on directory listing"},"fullDescription":{"text":"Missing access restriction on directory listing"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nExposing a directory listing without restrictions can lead to unauthorized access to sensitive data or source code. This vulnerability occurs when the file structure of a server or application is made visible to users without proper access control, potentially allowing attackers to exploit the exposed file structure.\n\n## Remediations\n\n- **Do** restrict access to sensitive directories and files to prevent unauthorized access. Implementing access controls ensures that only authorized users can view or interact with specific file directories.\n\n## References\n\n- [Express Serve index middleware](https://expressjs.com/en/resources/middleware/serve-index.html)","markdown":"## Description\n\nExposing a directory listing without restrictions can lead to unauthorized access to sensitive data or source code. This vulnerability occurs when the file structure of a server or application is made visible to users without proper access control, potentially allowing attackers to exploit the exposed file structure.\n\n## Remediations\n\n- **Do** restrict access to sensitive directories and files to prevent unauthorized access. Implementing access controls ensures that only authorized users can view or interact with specific file directories.\n\n## References\n\n- [Express Serve index middleware](https://expressjs.com/en/resources/middleware/serve-index.html)"}},{"id":"javascript_lang_post_message_origin","name":"javascript_lang_post_message_origin","shortDescription":{"text":"Permissive origin in postMessage"},"fullDescription":{"text":"Permissive origin in postMessage"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe use of a permissive origin in postMessage calls poses a security risk. When you set the target origin to \"*\" in a postMessage call, it means any website can receive the message, potentially exposing sensitive information to third parties.\n\n## Remediations\n\n- **Do not** use \"*\" as the target origin in postMessage calls. This approach is insecure as it allows any website to receive the messages.\n  ```javascript\n  window.postMessage(message, '*'); // unsafe\n  ```\n- **Do** specify the exact origin of the target application when using postMessage. This practice ensures that only the intended recipient can read the message.\n  ```javascript\n  window.postMessage(message, 'https://myapp.example.com');\n  ```","markdown":"## Description\n\nThe use of a permissive origin in postMessage calls poses a security risk. When you set the target origin to \"*\" in a postMessage call, it means any website can receive the message, potentially exposing sensitive information to third parties.\n\n## Remediations\n\n- **Do not** use \"*\" as the target origin in postMessage calls. This approach is insecure as it allows any website to receive the messages.\n  ```javascript\n  window.postMessage(message, '*'); // unsafe\n  ```\n- **Do** specify the exact origin of the target application when using postMessage. This practice ensures that only the intended recipient can read the message.\n  ```javascript\n  window.postMessage(message, 'https://myapp.example.com');\n  ```"}},{"id":"javascript_lang_http_url_using_user_input","name":"javascript_lang_http_url_using_user_input","shortDescription":{"text":"Unsanitized user input in HTTP request (SSRF)"},"fullDescription":{"text":"Unsanitized user input in HTTP request (SSRF)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nConstructing URLs based on user input puts your application at risk of Server-Side Request Forgery (SSRF) attacks. This vulnerability allows attackers to manipulate the application into making unintended HTTP requests.\n\n## Remediations\n\n- **Do not** directly incorporate user input into URLs for HTTP requests. This can lead to SSRF vulnerabilities.\n  ```javascript\n  const response = axios.get(`https://${req.params.host}`) // unsafe\n  ```\n- **Do** validate or map user input against a predefined list of allowed values before using it to form URLs. This approach minimizes the risk of SSRF attacks.\n  ```javascript\n  const hosts = new Map([\n    [\"option1\", \"api1.com\"],\n    [\"option2\", \"api2.com\"]\n  ])\n\n  const host = hosts.get(req.params.host)\n  const response = axios.get(`https://${host}`)\n  ```","markdown":"## Description\n\nConstructing URLs based on user input puts your application at risk of Server-Side Request Forgery (SSRF) attacks. This vulnerability allows attackers to manipulate the application into making unintended HTTP requests.\n\n## Remediations\n\n- **Do not** directly incorporate user input into URLs for HTTP requests. This can lead to SSRF vulnerabilities.\n  ```javascript\n  const response = axios.get(`https://${req.params.host}`) // unsafe\n  ```\n- **Do** validate or map user input against a predefined list of allowed values before using it to form URLs. This approach minimizes the risk of SSRF attacks.\n  ```javascript\n  const hosts = new Map([\n    [\"option1\", \"api1.com\"],\n    [\"option2\", \"api2.com\"]\n  ])\n\n  const host = hosts.get(req.params.host)\n  const response = axios.get(`https://${host}`)\n  ```"}},{"id":"javascript_express_unsafe_deserialization","name":"javascript_express_unsafe_deserialization","shortDescription":{"text":"Unsanitized user input in deserialization method"},"fullDescription":{"text":"Unsanitized user input in deserialization method"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nDeserializing untrusted data exposes your application to security risks. This vulnerability occurs when data, especially from external sources like request objects, is deserialized without proper sanitization. Attackers can embed malicious code or payloads in serialized data, compromising your application's security upon deserialization.\n\n## Remediations\n\n- **Do not** deserialize data from untrusted sources directly. This practice can lead to security vulnerabilities by executing malicious code embedded in the data.\n- **Do** use data-only and language-agnostic serialization formats such as JSON or XML for deserializing data. These formats are less susceptible to manipulation by attackers aiming to exploit the deserialization process.\n  ```javascript\n  JSON.parse(req.params);\n  ```\n\n## References\n\n- [OWASP Deserialization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)","markdown":"## Description\n\nDeserializing untrusted data exposes your application to security risks. This vulnerability occurs when data, especially from external sources like request objects, is deserialized without proper sanitization. Attackers can embed malicious code or payloads in serialized data, compromising your application's security upon deserialization.\n\n## Remediations\n\n- **Do not** deserialize data from untrusted sources directly. This practice can lead to security vulnerabilities by executing malicious code embedded in the data.\n- **Do** use data-only and language-agnostic serialization formats such as JSON or XML for deserializing data. These formats are less susceptible to manipulation by attackers aiming to exploit the deserialization process.\n  ```javascript\n  JSON.parse(req.params);\n  ```\n\n## References\n\n- [OWASP Deserialization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)"}},{"id":"javascript_react_dangerously_set_inner_html","name":"javascript_react_dangerously_set_inner_html","shortDescription":{"text":"Unsanitized user input in React inner HTML method (XSS)"},"fullDescription":{"text":"Unsanitized user input in React inner HTML method (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing React's dangerouslySetInnerHTML with unsanitized data can introduce Cross-Site Scripting (XSS) vulnerabilities. This occurs when external input is embedded directly into the HTML without proper sanitization, allowing attackers to inject malicious scripts.\n\n## Remediations\n\n- **Do** sanitize data before using it with dangerouslySetInnerHTML. This step is crucial to prevent XSS attacks by ensuring that the input does not contain harmful scripts.\n```javascript\n\u003cdiv dangerouslySetInnerHTML={{__html: sanitize(data)}} /\u003e\n```\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nUsing React's dangerouslySetInnerHTML with unsanitized data can introduce Cross-Site Scripting (XSS) vulnerabilities. This occurs when external input is embedded directly into the HTML without proper sanitization, allowing attackers to inject malicious scripts.\n\n## Remediations\n\n- **Do** sanitize data before using it with dangerouslySetInnerHTML. This step is crucial to prevent XSS attacks by ensuring that the input does not contain harmful scripts.\n```javascript\n\u003cdiv dangerouslySetInnerHTML={{__html: sanitize(data)}} /\u003e\n```\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)"}},{"id":"javascript_express_external_file_upload","name":"javascript_express_external_file_upload","shortDescription":{"text":"Unsanitized user input in HTTP send file request"},"fullDescription":{"text":"Unsanitized user input in HTTP send file request"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input in the sendFile API call exposes your application to path manipulation attacks. This vulnerability allows attackers to access files and resources they shouldn't be able to, by manipulating file paths in requests.\n\n## Remediations\n\n- **Do** set the `root` option to an absolute path to a directory when using `sendFile`. This confines the accessible files to a specific directory, preventing attackers from accessing files outside of this directory.\n  ```javascript\n  app.post(\"/upload\", (req, res) =\u003e {\n    var options = {\n      root: path.join(__dirname, \"upload\")\n    };\n    res.sendFile(req.params.filename, options);\n  });\n  ```\n\n## References\n\n- [Express sendFile API reference](http://expressjs.com/en/5x/api.html#res.sendFile)","markdown":"## Description\n\nUsing unsanitized user input in the sendFile API call exposes your application to path manipulation attacks. This vulnerability allows attackers to access files and resources they shouldn't be able to, by manipulating file paths in requests.\n\n## Remediations\n\n- **Do** set the `root` option to an absolute path to a directory when using `sendFile`. This confines the accessible files to a specific directory, preventing attackers from accessing files outside of this directory.\n  ```javascript\n  app.post(\"/upload\", (req, res) =\u003e {\n    var options = {\n      root: path.join(__dirname, \"upload\")\n    };\n    res.sendFile(req.params.filename, options);\n  });\n  ```\n\n## References\n\n- [Express sendFile API reference](http://expressjs.com/en/5x/api.html#res.sendFile)"}},{"id":"java_lang_insufficiently_random_values","name":"java_lang_insufficiently_random_values","shortDescription":{"text":"Usage of insufficient random value"},"fullDescription":{"text":"Usage of insufficient random value"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe use of predictable random values compromises application security, particularly when these values serve security-related functions.\n\n## Remediations\n\n- **Do** utilize a robust library for generating random values to enhance security.\n  ```java\n  SecureRandom random = new SecureRandom();\n  ```\n\n## References\n\n- [Java SecureRandom class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/SecureRandom.html)","markdown":"## Description\n\nThe use of predictable random values compromises application security, particularly when these values serve security-related functions.\n\n## Remediations\n\n- **Do** utilize a robust library for generating random values to enhance security.\n  ```java\n  SecureRandom random = new SecureRandom();\n  ```\n\n## References\n\n- [Java SecureRandom class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/SecureRandom.html)"}},{"id":"javascript_lang_eval_user_input","name":"javascript_lang_eval_user_input","shortDescription":{"text":"Unsanitized user input in 'eval' type function"},"fullDescription":{"text":"Unsanitized user input in 'eval' type function"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nAllowing user input to directly influence the behavior of `eval` and similar functions like `setTimeout` poses a significant security risk, potentially leading to remote code execution attacks. This vulnerability stems from the dynamic execution of code, which can be maliciously crafted by an attacker.\n\n## Remediations\n\n- **Do not** use `eval` or similar code execution functions directly with user input. This approach can make your application vulnerable to attacks.\n  ```javascript\n  eval(userInput); // unsafe\n  ```\n- **Do** use static, hardcoded values when working with dynamic code execution methods. This method ensures that only predefined operations are performed, reducing the risk of executing malicious code.\n  ```javascript\n    let myFunc = \"(a, b) =\u003e a + b\";\n    if (req.params[\"single_item\"]) {\n      myFunc = \"(a) =\u003e a\";\n    }\n  ```\n- **Do** consider using compiled functions instead of dynamically compiling code with user input. This practice allows for safer execution of dynamic operations by predefining the code to be executed.\n- **Do** enable JavaScript's strict mode in your code. This mode helps to catch common coding bloopers, prevents unsafe actions, and limits certain features that can make your code more secure.\n  ```javascript\n  \"use strict\";\n  ```\n\n## References\n\n- [MDN JavaScript strict mode reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)","markdown":"## Description\n\nAllowing user input to directly influence the behavior of `eval` and similar functions like `setTimeout` poses a significant security risk, potentially leading to remote code execution attacks. This vulnerability stems from the dynamic execution of code, which can be maliciously crafted by an attacker.\n\n## Remediations\n\n- **Do not** use `eval` or similar code execution functions directly with user input. This approach can make your application vulnerable to attacks.\n  ```javascript\n  eval(userInput); // unsafe\n  ```\n- **Do** use static, hardcoded values when working with dynamic code execution methods. This method ensures that only predefined operations are performed, reducing the risk of executing malicious code.\n  ```javascript\n    let myFunc = \"(a, b) =\u003e a + b\";\n    if (req.params[\"single_item\"]) {\n      myFunc = \"(a) =\u003e a\";\n    }\n  ```\n- **Do** consider using compiled functions instead of dynamically compiling code with user input. This practice allows for safer execution of dynamic operations by predefining the code to be executed.\n- **Do** enable JavaScript's strict mode in your code. This mode helps to catch common coding bloopers, prevents unsafe actions, and limits certain features that can make your code more secure.\n  ```javascript\n  \"use strict\";\n  ```\n\n## References\n\n- [MDN JavaScript strict mode reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)"}},{"id":"javascript_third_parties_elasticsearch","name":"javascript_third_parties_elasticsearch","shortDescription":{"text":"Leakage of sensitive data to ElasticSearch"},"fullDescription":{"text":"Leakage of sensitive data to ElasticSearch"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party data tools is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like ElasticSearch\n\n## References\n- [Elasticsearch docs](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party data tools is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like ElasticSearch\n\n## References\n- [Elasticsearch docs](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html)\n"}},{"id":"javascript_express_open_redirect","name":"javascript_express_open_redirect","shortDescription":{"text":"Unsanitized user input in redirect"},"fullDescription":{"text":"Unsanitized user input in redirect"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input for redirection can expose your application to phishing attacks. This vulnerability occurs when user input directly influences the destination of a redirect without proper validation, making it easier for attackers to redirect users to malicious sites.\n\n## Remediations\n\n- **Do not** use unsanitized user input to construct URLs for redirection. This can lead to security vulnerabilities where attackers could exploit the redirect to lead users to malicious sites.\n- **Do** validate user input by employing a safe list or a mapping strategy for constructing URLs. This ensures that only pre-approved destinations are used for redirects, significantly reducing the risk of phishing attacks.\n  ```javascript\n  var map = {\n    \"1\": \"/planes\",\n    \"2\": \"/trains\",\n    \"3\": \"/automobiles\",\n  }\n\n  res.redirect(map[req.body.transport])\n  ```\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized user input for redirection can expose your application to phishing attacks. This vulnerability occurs when user input directly influences the destination of a redirect without proper validation, making it easier for attackers to redirect users to malicious sites.\n\n## Remediations\n\n- **Do not** use unsanitized user input to construct URLs for redirection. This can lead to security vulnerabilities where attackers could exploit the redirect to lead users to malicious sites.\n- **Do** validate user input by employing a safe list or a mapping strategy for constructing URLs. This ensures that only pre-approved destinations are used for redirects, significantly reducing the risk of phishing attacks.\n  ```javascript\n  var map = {\n    \"1\": \"/planes\",\n    \"2\": \"/trains\",\n    \"3\": \"/automobiles\",\n  }\n\n  res.redirect(map[req.body.transport])\n  ```\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)"}},{"id":"java_lang_http_parameter_pollution","name":"java_lang_http_parameter_pollution","shortDescription":{"text":"Possible HTTP Parameter Pollution detected"},"fullDescription":{"text":"Possible HTTP Parameter Pollution detected"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input to construct a URL can lead to HTTP Parameter Pollution (HPP) attacks. In such attacks, an attacker can manipulate the URL or request parameters to alter requests or access hidden information.\n\n## Remediations\n\n- **Do not** use direct or unsanitized user input when constructing URLs or URL parameters.\n- **Do** use alternative and safe methods to incorporate user input when constructing URLs. For example, a lookup table.\n  ```java\n  HashMap\u003cString, String\u003e lookupTable = new HashMap\u003c\u003e();\n  // ... populate hash map\n  String rawUserInput = request.getParameter(\"someParam\");\n  String value = lookupTable.getOrDefault(rawUserInput, \"someDefault\");\n  HttpGet httpget = new HttpGet(\"https://example.com/?param=\" + value);\n  ```\n- **Do** sanitize user input before using it in your URLs. This step ensures that any harmful characters or attempts to manipulate the URL are neutralized.\n  ```java\n  String rawUserInput = request.getParameter(\"someParam\");\n  String encoded = java.net.URLEncoder.encode(rawUserInput, StandardCharsets.UTF_8);\n  ```","markdown":"## Description\n\nUsing unsanitized user input to construct a URL can lead to HTTP Parameter Pollution (HPP) attacks. In such attacks, an attacker can manipulate the URL or request parameters to alter requests or access hidden information.\n\n## Remediations\n\n- **Do not** use direct or unsanitized user input when constructing URLs or URL parameters.\n- **Do** use alternative and safe methods to incorporate user input when constructing URLs. For example, a lookup table.\n  ```java\n  HashMap\u003cString, String\u003e lookupTable = new HashMap\u003c\u003e();\n  // ... populate hash map\n  String rawUserInput = request.getParameter(\"someParam\");\n  String value = lookupTable.getOrDefault(rawUserInput, \"someDefault\");\n  HttpGet httpget = new HttpGet(\"https://example.com/?param=\" + value);\n  ```\n- **Do** sanitize user input before using it in your URLs. This step ensures that any harmful characters or attempts to manipulate the URL are neutralized.\n  ```java\n  String rawUserInput = request.getParameter(\"someParam\");\n  String encoded = java.net.URLEncoder.encode(rawUserInput, StandardCharsets.UTF_8);\n  ```"}},{"id":"javascript_express_hardcoded_secret","name":"javascript_express_hardcoded_secret","shortDescription":{"text":"Usage of hard-coded secret"},"fullDescription":{"text":"Usage of hard-coded secret"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nStoring secrets directly in code compromises security. It's safer to use environment variables or a secret management system.\n\n## Remediations\n\n- **Do not** store plaintext secrets in your code. This makes your application vulnerable to unauthorized access if the codebase is exposed.\n  ```javascript\n  app.use(\n    session({\n      secret: \"shh-my-secret\",\n      name: \"my-custom-session-name\",\n    })\n  )\n  ```\n- **Do** use environment variables to store secrets. This method keeps sensitive information out of your codebase.\n  ```javascript\n  app.use(\n    session({\n      secret: process.env.SECRET,\n      name: \"my-custom-session-name\",\n    })\n  )\n  ```\n- **Do** use a secret management system or a key management service (KMS) with encryption for enhanced security. These services provide secure storage and management of secrets, reducing the risk of exposure.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)\n- [Google Cloud Key Management Service](https://cloud.google.com/kms/docs)\n- [AWS Key Management Service](https://aws.amazon.com/kms/)\n","markdown":"## Description\n\nStoring secrets directly in code compromises security. It's safer to use environment variables or a secret management system.\n\n## Remediations\n\n- **Do not** store plaintext secrets in your code. This makes your application vulnerable to unauthorized access if the codebase is exposed.\n  ```javascript\n  app.use(\n    session({\n      secret: \"shh-my-secret\",\n      name: \"my-custom-session-name\",\n    })\n  )\n  ```\n- **Do** use environment variables to store secrets. This method keeps sensitive information out of your codebase.\n  ```javascript\n  app.use(\n    session({\n      secret: process.env.SECRET,\n      name: \"my-custom-session-name\",\n    })\n  )\n  ```\n- **Do** use a secret management system or a key management service (KMS) with encryption for enhanced security. These services provide secure storage and management of secrets, reducing the risk of exposure.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)\n- [Google Cloud Key Management Service](https://cloud.google.com/kms/docs)\n- [AWS Key Management Service](https://aws.amazon.com/kms/)\n"}},{"id":"javascript_lang_unsafe_deserialization","name":"javascript_lang_unsafe_deserialization","shortDescription":{"text":"Unsanitized user input in deserialization method"},"fullDescription":{"text":"Unsanitized user input in deserialization method"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nDeserializing untrusted data is a risky practice. This vulnerability arises when data, especially from external sources like request objects, is deserialized without proper sanitization. Attackers can embed malicious payloads within serialized data, compromising your application's security upon deserialization.\n\n## Remediations\n\n- **Do not** deserialize data that comes directly from untrusted sources. This prevents attackers from injecting malicious payloads that could compromise your application.\n- **Do** opt for data-only and language-neutral serialization formats like JSON or XML for deserializing data. These formats are less susceptible to manipulation by attackers aiming to exploit the deserialization process.\n  ```javascript\n  JSON.parse(req.params);\n  ```\n\n## References\n\n- [OWASP Deserialization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)","markdown":"## Description\n\nDeserializing untrusted data is a risky practice. This vulnerability arises when data, especially from external sources like request objects, is deserialized without proper sanitization. Attackers can embed malicious payloads within serialized data, compromising your application's security upon deserialization.\n\n## Remediations\n\n- **Do not** deserialize data that comes directly from untrusted sources. This prevents attackers from injecting malicious payloads that could compromise your application.\n- **Do** opt for data-only and language-neutral serialization formats like JSON or XML for deserializing data. These formats are less susceptible to manipulation by attackers aiming to exploit the deserialization process.\n  ```javascript\n  JSON.parse(req.params);\n  ```\n\n## References\n\n- [OWASP Deserialization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)"}},{"id":"java_lang_dangerous_permissions","name":"java_lang_dangerous_permissions","shortDescription":{"text":"Usage of dangerous permissions"},"fullDescription":{"text":"Usage of dangerous permissions"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nGranting certain (dangerous) permissions compromises application security. Specifically, allowing `RuntimePermission` of `createClassLoader` can lead to unauthorized class loaders being used to load arbitrary classes. Similarly, permitting `ReflectPermission` of `suppressAccessChecks` bypasses Java language access controls, risking unrestricted access to protected and private class members.\n\n## Remediations\n\n- **Do not** grant `RuntimePermission(\"createClassLoader\")`. This permission enables the instantiation of unauthorized class loaders, posing a security risk by potentially loading arbitrary classes.\n- **Do not** grant `ReflectPermission(\"suppressAccessChecks\")`. This permission allows bypassing Java's access checks, leading to a risk of unrestricted access to protected and private class members.\n- **Do** review and restrict permissions to only what is necessary for the application's functionality. Limiting permissions minimizes potential security vulnerabilities.","markdown":"## Description\n\nGranting certain (dangerous) permissions compromises application security. Specifically, allowing `RuntimePermission` of `createClassLoader` can lead to unauthorized class loaders being used to load arbitrary classes. Similarly, permitting `ReflectPermission` of `suppressAccessChecks` bypasses Java language access controls, risking unrestricted access to protected and private class members.\n\n## Remediations\n\n- **Do not** grant `RuntimePermission(\"createClassLoader\")`. This permission enables the instantiation of unauthorized class loaders, posing a security risk by potentially loading arbitrary classes.\n- **Do not** grant `ReflectPermission(\"suppressAccessChecks\")`. This permission allows bypassing Java's access checks, leading to a risk of unrestricted access to protected and private class members.\n- **Do** review and restrict permissions to only what is necessary for the application's functionality. Limiting permissions minimizes potential security vulnerabilities."}},{"id":"javascript_third_parties_google_analytics","name":"javascript_third_parties_google_analytics","shortDescription":{"text":"Leakage of sensitive data to Google Analytics"},"fullDescription":{"text":"Leakage of sensitive data to Google Analytics"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party analytics tools like Google Analytics is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to analytics libraries like Google Analytics.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    gtag(\"event\", \"screen_view\", {\n      user: {\n        subscribed: true,\n      },\n    });\n  ```\n\n## References\n- [Google Analytics docs](https://developers.google.com/analytics/devguides/reporting/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party analytics tools like Google Analytics is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to analytics libraries like Google Analytics.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    gtag(\"event\", \"screen_view\", {\n      user: {\n        subscribed: true,\n      },\n    });\n  ```\n\n## References\n- [Google Analytics docs](https://developers.google.com/analytics/devguides/reporting/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n"}},{"id":"java_third_parties_aws_query_injection","name":"java_third_parties_aws_query_injection","shortDescription":{"text":"Unsanitized user input in AWS query"},"fullDescription":{"text":"Unsanitized user input in AWS query"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncluding unsanitized data, such as user input or request data, in raw queries makes your application vulnerable to injection attacks.\n\n## Remediations\n\n- **Do** always sanitize user input especially if it is to be used in database queries. Where possible, such sanitization should include the removal of special characters (like ' or \") that could be used to alter the semantics of a database query.\n- **Do** validate user input wherever possible, to ensure it is the expected format and length\n- **Do** use parameterized queries rather than concatenating user input directly into the query string. This separates query logic from user input, which is good practice, and also in the case of AWS SimpleDB, lets us take advantage of the internal parameterization and sanitization of `SelectRequest`.\n  ```java\n    // query logic\n    public static SelectResult executeQuery(String query, String itemName) {\n      AmazonSimpleDB simpleDBClient = AmazonSimpleDBClientBuilder.defaultClient();\n      SelectRequest selectRequest = new SelectRequest(query, true).withNextToken(itemName);\n\n      return simpleDBClient.select(selectRequest);\n    }\n\n    public static void selectItem(String itemName) { // itemName is dynamic and could be malicious\n      // parameterized query string\n      String query = \"select * from items where itemName = ?\";\n\n      SelectResult result = executeQuery(query, itemName);\n      ...\n    }\n  ```\n\n## References\n- [AWS SimpleDB docs](https://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/Welcome.html)\n","markdown":"## Description\n\nIncluding unsanitized data, such as user input or request data, in raw queries makes your application vulnerable to injection attacks.\n\n## Remediations\n\n- **Do** always sanitize user input especially if it is to be used in database queries. Where possible, such sanitization should include the removal of special characters (like ' or \") that could be used to alter the semantics of a database query.\n- **Do** validate user input wherever possible, to ensure it is the expected format and length\n- **Do** use parameterized queries rather than concatenating user input directly into the query string. This separates query logic from user input, which is good practice, and also in the case of AWS SimpleDB, lets us take advantage of the internal parameterization and sanitization of `SelectRequest`.\n  ```java\n    // query logic\n    public static SelectResult executeQuery(String query, String itemName) {\n      AmazonSimpleDB simpleDBClient = AmazonSimpleDBClientBuilder.defaultClient();\n      SelectRequest selectRequest = new SelectRequest(query, true).withNextToken(itemName);\n\n      return simpleDBClient.select(selectRequest);\n    }\n\n    public static void selectItem(String itemName) { // itemName is dynamic and could be malicious\n      // parameterized query string\n      String query = \"select * from items where itemName = ?\";\n\n      SelectResult result = executeQuery(query, itemName);\n      ...\n    }\n  ```\n\n## References\n- [AWS SimpleDB docs](https://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/Welcome.html)\n"}},{"id":"java_lang_weak_password_hash_sha1","name":"java_lang_weak_password_hash_sha1","shortDescription":{"text":"Usage of weak hashing library on a password (SHA-1)"},"fullDescription":{"text":"Usage of weak hashing library on a password (SHA-1)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a weak hashing library like SHA-1 for passwords increases the risk of data breaches. SHA-1 is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing passwords or sensitive data due to its vulnerabilities.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n  ```\n- **Do** opt for stronger hashing algorithms such as SHA-256 to enhance security.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)","markdown":"## Description\n\nUsing a weak hashing library like SHA-1 for passwords increases the risk of data breaches. SHA-1 is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing passwords or sensitive data due to its vulnerabilities.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n  ```\n- **Do** opt for stronger hashing algorithms such as SHA-256 to enhance security.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)"}},{"id":"java_lang_code_injection","name":"java_lang_code_injection","shortDescription":{"text":"Unsanitized user input in code generation"},"fullDescription":{"text":"Unsanitized user input in code generation"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nAllowing user input to directly influence code generation or scripting functions without proper sanitization can lead to code injection vulnerabilities. This occurs when an attacker is able to insert malicious code into your application, which is then executed, potentially leading to unauthorized actions or data access.\n\n## Remediations\n\n- **Do not** pass unsanitized user input to functions or methods that dynamically execute code.\n- **Do** always validate or sanitize input to ensure it does not contain harmful code before using it in such contexts.\n\n## References\n\n- [OWASP Code injection](https://owasp.org/www-community/attacks/Code_Injection)","markdown":"## Description\n\nAllowing user input to directly influence code generation or scripting functions without proper sanitization can lead to code injection vulnerabilities. This occurs when an attacker is able to insert malicious code into your application, which is then executed, potentially leading to unauthorized actions or data access.\n\n## Remediations\n\n- **Do not** pass unsanitized user input to functions or methods that dynamically execute code.\n- **Do** always validate or sanitize input to ensure it does not contain harmful code before using it in such contexts.\n\n## References\n\n- [OWASP Code injection](https://owasp.org/www-community/attacks/Code_Injection)"}},{"id":"java_lang_trust_boundary_violation","name":"java_lang_trust_boundary_violation","shortDescription":{"text":"Usage of trusted and untrusted data inside the same data structure"},"fullDescription":{"text":"Usage of trusted and untrusted data inside the same data structure"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nCombining trusted and untrusted data within a single data structure poses a significant security risk. This practice may result in untrusted data being incorrectly regarded as trustworthy, potentially leading to security vulnerabilities.\n\n## Remediations\n\n- **Do not** mix trusted and untrusted data in the same data structure. Keeping them separate ensures that untrusted data does not accidentally gain the same level of trust as the verified data.","markdown":"## Description\n\nCombining trusted and untrusted data within a single data structure poses a significant security risk. This practice may result in untrusted data being incorrectly regarded as trustworthy, potentially leading to security vulnerabilities.\n\n## Remediations\n\n- **Do not** mix trusted and untrusted data in the same data structure. Keeping them separate ensures that untrusted data does not accidentally gain the same level of trust as the verified data."}},{"id":"java_lang_ldap_injection","name":"java_lang_ldap_injection","shortDescription":{"text":"Unsanitized user input in LDAP request"},"fullDescription":{"text":"Unsanitized user input in LDAP request"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input in an LDAP request can lead to LDAP injection, which is when attackers can modify the LDAP tree structure by injecting malicious input. It's crucial to ensure that data passed to an LDAP query is either not controlled by the user or is properly sanitized.\n\n## Remediations\n\n- **Do** sanitize user input before including it in LDAP queries to prevent LDAP injection attacks.\n  ```java\n  public class Cls extends HttpServlet\n  {\n\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String userID = request.getParameter(\"userID\");\n          String sanitizedUserID = sanitize(userID); // Ensure sanitization method effectively neutralizes LDAP injection vectors\n\n          String filter = \"(\u0026(objectclass=person))(|(uid=\" + sanitizedUserID + \")(street={0}))\";\n          String base = \"ou=users,ou=system\";\n          Object[] filters = new Object[] {\"First avenue\"};\n          javax.naming.directory.SearchControls sc = new javax.naming.directory.SearchControls();\n\n          dirContext.search(base, filter, filters, sc);\n      }\n  }\n  ```\n\n## References\n\n- [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection)\n- [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized user input in an LDAP request can lead to LDAP injection, which is when attackers can modify the LDAP tree structure by injecting malicious input. It's crucial to ensure that data passed to an LDAP query is either not controlled by the user or is properly sanitized.\n\n## Remediations\n\n- **Do** sanitize user input before including it in LDAP queries to prevent LDAP injection attacks.\n  ```java\n  public class Cls extends HttpServlet\n  {\n\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String userID = request.getParameter(\"userID\");\n          String sanitizedUserID = sanitize(userID); // Ensure sanitization method effectively neutralizes LDAP injection vectors\n\n          String filter = \"(\u0026(objectclass=person))(|(uid=\" + sanitizedUserID + \")(street={0}))\";\n          String base = \"ou=users,ou=system\";\n          Object[] filters = new Object[] {\"First avenue\"};\n          javax.naming.directory.SearchControls sc = new javax.naming.directory.SearchControls();\n\n          dirContext.search(base, filter, filters, sc);\n      }\n  }\n  ```\n\n## References\n\n- [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection)\n- [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)"}},{"id":"javascript_express_insecure_allow_origin","name":"javascript_express_insecure_allow_origin","shortDescription":{"text":"Unsanitized user input in Access-Control-Allow-Origin"},"fullDescription":{"text":"Unsanitized user input in Access-Control-Allow-Origin"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unverified user-defined input to set the Access-Control-Allow-Origin header can result in unauthorized access to sensitive data. This vulnerability exposes your application to potential security risks by allowing attackers to specify origins that can access resources.\n\n## Remediations\n\n- **Do not** define the Access-Control-Allow-Origin header with user input. This practice can compromise the security of your application by allowing data access to unintended users.\n- **Do** verify user input if it is absolutely necessary to use it for defining origins. Ensure that the verification process is robust to prevent security breaches.\n- **Do** use a safelist approach when specifying origins. This uses a predefined list of trusted origins and only allows requests from those origins.\n\n## References\n\n- [OWASP Origin \u0026 Access-Control-Allow-Origin](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing)","markdown":"## Description\n\nUsing unverified user-defined input to set the Access-Control-Allow-Origin header can result in unauthorized access to sensitive data. This vulnerability exposes your application to potential security risks by allowing attackers to specify origins that can access resources.\n\n## Remediations\n\n- **Do not** define the Access-Control-Allow-Origin header with user input. This practice can compromise the security of your application by allowing data access to unintended users.\n- **Do** verify user input if it is absolutely necessary to use it for defining origins. Ensure that the verification process is robust to prevent security breaches.\n- **Do** use a safelist approach when specifying origins. This uses a predefined list of trusted origins and only allows requests from those origins.\n\n## References\n\n- [OWASP Origin \u0026 Access-Control-Allow-Origin](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing)"}},{"id":"javascript_express_cookie_missing_http_only","name":"javascript_express_cookie_missing_http_only","shortDescription":{"text":"Missing HTTP Only option in cookie configuration"},"fullDescription":{"text":"Missing HTTP Only option in cookie configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour cookies are at risk if the HTTP Only option is not configured. This setting prevents client-side JavaScript, such as the code that reads \"document.cookie\" values, from accessing the cookie's value. Enabling this option is crucial for websites prone to Cross-Site Scripting (XSS) attacks, because it prevents malicious scripts from obtaining the cookie's data.\n\n## Remediations\n\n- **Do** set the `HttpOnly` attribute to `true` in your cookie configuration. This action ensures that cookies are shielded from unauthorized client-side access.\n  ```javascript\n  cookie({ httpOnly: true });\n  ```\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)","markdown":"## Description\n\nYour cookies are at risk if the HTTP Only option is not configured. This setting prevents client-side JavaScript, such as the code that reads \"document.cookie\" values, from accessing the cookie's value. Enabling this option is crucial for websites prone to Cross-Site Scripting (XSS) attacks, because it prevents malicious scripts from obtaining the cookie's data.\n\n## Remediations\n\n- **Do** set the `HttpOnly` attribute to `true` in your cookie configuration. This action ensures that cookies are shielded from unauthorized client-side access.\n  ```javascript\n  cookie({ httpOnly: true });\n  ```\n\n## References\n\n- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely)"}},{"id":"javascript_lang_jwt_weak_encryption","name":"javascript_lang_jwt_weak_encryption","shortDescription":{"text":"Usage of weak encryption algorithm in JWT"},"fullDescription":{"text":"Usage of weak encryption algorithm in JWT"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nImplementing weak encryption algorithms in JWT (JSON Web Tokens) compromises the security of the tokens. This vulnerability occurs when an encryption algorithm that does not offer sufficient security strength is used, making the tokens susceptible to attacks.\n\n## Remediations\n\n- **Do** use robust encryption algorithms recommended for JWT. HS256 (HMAC with SHA-256) is a secure choice for signing JWTs.\n  ```javascript\n  jwt.sign({ \"foo\": \"bar\"}, process.env.JWT_SECRET, {\n    algorithm: \"HS256\"\n  })\n  ```\n\n## References\n\n- [OWASP weak encryption](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/04-Testing_for_Weak_Encryption)","markdown":"## Description\n\nImplementing weak encryption algorithms in JWT (JSON Web Tokens) compromises the security of the tokens. This vulnerability occurs when an encryption algorithm that does not offer sufficient security strength is used, making the tokens susceptible to attacks.\n\n## Remediations\n\n- **Do** use robust encryption algorithms recommended for JWT. HS256 (HMAC with SHA-256) is a secure choice for signing JWTs.\n  ```javascript\n  jwt.sign({ \"foo\": \"bar\"}, process.env.JWT_SECRET, {\n    algorithm: \"HS256\"\n  })\n  ```\n\n## References\n\n- [OWASP weak encryption](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/04-Testing_for_Weak_Encryption)"}},{"id":"javascript_express_external_resource","name":"javascript_express_external_resource","shortDescription":{"text":"Unsanitized user input in resource rendering"},"fullDescription":{"text":"Unsanitized user input in resource rendering"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUnsanitized user input in resource rendering can lead to security vulnerabilities. This issue arises when user-provided data is used directly in rendering resources without proper sanitization, potentially leading to unauthorized access or manipulation of data.\n\n## Remediations\n\n- **Do not** pass user or request input directly to `res.render()` without sanitization. Directly using user input in resource rendering can introduce security risks.\n  ```javascript\n  res.render(req.body.page); // unsafe\n  ```\n- **Do** sanitize the input or use a safelist if you must rely on user input for resource rendering. This ensures that only expected and safe resources are rendered.\n  ```javascript\n  var path = req.body.path;\n  if (['users', 'posts', 'pages'].includes(path)) {\n    return res.render(`${path}/success`);\n  }\n  ```","markdown":"## Description\n\nUnsanitized user input in resource rendering can lead to security vulnerabilities. This issue arises when user-provided data is used directly in rendering resources without proper sanitization, potentially leading to unauthorized access or manipulation of data.\n\n## Remediations\n\n- **Do not** pass user or request input directly to `res.render()` without sanitization. Directly using user input in resource rendering can introduce security risks.\n  ```javascript\n  res.render(req.body.page); // unsafe\n  ```\n- **Do** sanitize the input or use a safelist if you must rely on user input for resource rendering. This ensures that only expected and safe resources are rendered.\n  ```javascript\n  var path = req.body.path;\n  if (['users', 'posts', 'pages'].includes(path)) {\n    return res.render(`${path}/success`);\n  }\n  ```"}},{"id":"java_lang_ssl_verification","name":"java_lang_ssl_verification","shortDescription":{"text":"Missing TLS validation"},"fullDescription":{"text":"Missing TLS validation"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour code is vulnerable to Man-in-the-Middle attacks if it doesn't validate TLS certificates. This issue arises when your application establishes a connection without verifying the server's hostname, making it susceptible to data interception and other security risks.  Using deprecated elements like `DefaultHttpClient`, which lacks hostname verification, or the SSL protocol, known for its security flaws, exacerbates these vulnerabilities.\n\n## Remediations\n\n- **Do** use newer HTTP Clients such as `java.net.http.HttpClient` that automatically include TLS validation.\n- **Do** opt for the newer TLS protocol over SSL, wherever possible, to secure connections. Ensure your application explicitly requests TLS to avoid the vulnerabilities associated with SSL.\n  ```java\n  SSLContext.getInstance(\"TLS\");\n  ```\n- **Do not** rely on deprecated HTTP clients, such as `DefaultHttpClient`, for your application's networking needs. These clients do not perform necessary security checks like TLS validation, putting your application at risk.","markdown":"## Description\n\nYour code is vulnerable to Man-in-the-Middle attacks if it doesn't validate TLS certificates. This issue arises when your application establishes a connection without verifying the server's hostname, making it susceptible to data interception and other security risks.  Using deprecated elements like `DefaultHttpClient`, which lacks hostname verification, or the SSL protocol, known for its security flaws, exacerbates these vulnerabilities.\n\n## Remediations\n\n- **Do** use newer HTTP Clients such as `java.net.http.HttpClient` that automatically include TLS validation.\n- **Do** opt for the newer TLS protocol over SSL, wherever possible, to secure connections. Ensure your application explicitly requests TLS to avoid the vulnerabilities associated with SSL.\n  ```java\n  SSLContext.getInstance(\"TLS\");\n  ```\n- **Do not** rely on deprecated HTTP clients, such as `DefaultHttpClient`, for your application's networking needs. These clients do not perform necessary security checks like TLS validation, putting your application at risk."}},{"id":"javascript_react_google_analytics","name":"javascript_react_google_analytics","shortDescription":{"text":"Leakage of sensitive data to Google Analytics (React)"},"fullDescription":{"text":"Leakage of sensitive data to Google Analytics (React)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nSending sensitive data to Google Analytics can result in data leaks. This vulnerability arises when sensitive or confidential information is inadvertently transmitted to Google Analytics, posing a risk of unauthorized access and potential data breaches.\n\n## Remediations\n\n- **Do not** include sensitive information in data payloads sent to Google Analytics. Always review the data being transmitted to ensure it does not contain personal or confidential details.\n- **Do** use data processing techniques to anonymize or remove sensitive data before sending it to Google Analytics. This can include techniques like hashing or tokenization to ensure that any data transmitted cannot be used to identify an individual.","markdown":"## Description\n\nSending sensitive data to Google Analytics can result in data leaks. This vulnerability arises when sensitive or confidential information is inadvertently transmitted to Google Analytics, posing a risk of unauthorized access and potential data breaches.\n\n## Remediations\n\n- **Do not** include sensitive information in data payloads sent to Google Analytics. Always review the data being transmitted to ensure it does not contain personal or confidential details.\n- **Do** use data processing techniques to anonymize or remove sensitive data before sending it to Google Analytics. This can include techniques like hashing or tokenization to ensure that any data transmitted cannot be used to identify an individual."}},{"id":"java_lang_hardcoded_secret","name":"java_lang_hardcoded_secret","shortDescription":{"text":"Usage of hard-coded secret"},"fullDescription":{"text":"Usage of hard-coded secret"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nApplications should store secret values securely and not as literal values\nin the source code.\n\n## Remediations\n\n✅ Retrieve secrets from a secure location at runtime\n\n## Resources\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)\n- [OWASP secrets management cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html#21-high-availability)\n","markdown":"## Description\n\nApplications should store secret values securely and not as literal values\nin the source code.\n\n## Remediations\n\n✅ Retrieve secrets from a secure location at runtime\n\n## Resources\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)\n- [OWASP secrets management cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html#21-high-availability)\n"}},{"id":"javascript_third_parties_bugsnag","name":"javascript_third_parties_bugsnag","shortDescription":{"text":"Leakage of sensitive data to Bugsnag"},"fullDescription":{"text":"Leakage of sensitive data to Bugsnag"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party loggers like Bugsnag is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Bugsnag.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    import { Bugsnag } from \"@bugsnag/js\"\n\n    var bugSession = Bugsnag.startSession()\n    bugSession.notify(user.uuid)\n  ```\n\n## References\n- [Bugsnag Docs](https://docs.bugsnag.com/platforms/javascript/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n","markdown":"## Description\n\nLeaking sensitive data to third-party loggers like Bugsnag is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party loggers like Bugsnag.\n- **Do** use unique identifiers from the database if you really need to identify users.\n  ```javascript\n    import { Bugsnag } from \"@bugsnag/js\"\n\n    var bugSession = Bugsnag.startSession()\n    bugSession.notify(user.uuid)\n  ```\n\n## References\n- [Bugsnag Docs](https://docs.bugsnag.com/platforms/javascript/)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n"}},{"id":"javascript_lang_weak_password_hash_md5","name":"javascript_lang_weak_password_hash_md5","shortDescription":{"text":"Usage of weak hashing library on a password (MD5)"},"fullDescription":{"text":"Usage of weak hashing library on a password (MD5)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a weak hashing library like MD5 for password storage compromises security. MD5 is outdated and vulnerable, making it easier for attackers to crack passwords and gain unauthorized access.\n\n## Remediations\n\n- **Do not** use MD5 for hashing passwords or any sensitive data. It is no longer considered secure.\n- **Do** use a strong and recommended hashing library such as Argon2id for hashing passwords. This method enhances security by making it significantly harder for attackers to crack stored passwords.\n  ```javascript\n  const argon2 = require(\"argon2\");\n  const hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n  ```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)","markdown":"## Description\n\nUsing a weak hashing library like MD5 for password storage compromises security. MD5 is outdated and vulnerable, making it easier for attackers to crack passwords and gain unauthorized access.\n\n## Remediations\n\n- **Do not** use MD5 for hashing passwords or any sensitive data. It is no longer considered secure.\n- **Do** use a strong and recommended hashing library such as Argon2id for hashing passwords. This method enhances security by making it significantly harder for attackers to crack stored passwords.\n  ```javascript\n  const argon2 = require(\"argon2\");\n  const hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n  ```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)"}},{"id":"java_lang_blowfish_key_size","name":"java_lang_blowfish_key_size","shortDescription":{"text":"Usage of small key size with Blowfish encryption"},"fullDescription":{"text":"Usage of small key size with Blowfish encryption"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing Blowfish encryption with a small key size (128 bytes or less) makes your data susceptible to birthday attacks. This vulnerability arises because smaller key sizes don't provide enough complexity to secure the encrypted data effectively. It is recommended to specify a larger value, such as 256, instead.\n\n## Remediations\n\n- **Do** increase the key size when using Blowfish encryption. Specifically, set the key size to 256 or more using the `KeyGenerator.init(keySize)` method. This adjustment significantly improves the security of the encryption.\n  ```java\n  KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n  keyGenerator.init(256);\n  ```\n- **Do** consider using AES for encryption instead of Blowfish. AES is a more secure and widely recommended encryption standard. You can select AES as your encryption method by initializing the KeyGenerator instance for AES.\n  ```java\n  KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n  ```\n\n## References\n\n- [Java Cryptography Architecture docs](https://docs.oracle.com/en/java/javase/21/security/java-cryptography-architecture-jca-reference-guide.html)\n- [Birthday Attack](https://en.wikipedia.org/wiki/Birthday_attack)","markdown":"## Description\n\nUsing Blowfish encryption with a small key size (128 bytes or less) makes your data susceptible to birthday attacks. This vulnerability arises because smaller key sizes don't provide enough complexity to secure the encrypted data effectively. It is recommended to specify a larger value, such as 256, instead.\n\n## Remediations\n\n- **Do** increase the key size when using Blowfish encryption. Specifically, set the key size to 256 or more using the `KeyGenerator.init(keySize)` method. This adjustment significantly improves the security of the encryption.\n  ```java\n  KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n  keyGenerator.init(256);\n  ```\n- **Do** consider using AES for encryption instead of Blowfish. AES is a more secure and widely recommended encryption standard. You can select AES as your encryption method by initializing the KeyGenerator instance for AES.\n  ```java\n  KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n  ```\n\n## References\n\n- [Java Cryptography Architecture docs](https://docs.oracle.com/en/java/javase/21/security/java-cryptography-architecture-jca-reference-guide.html)\n- [Birthday Attack](https://en.wikipedia.org/wiki/Birthday_attack)"}},{"id":"javascript_express_server_side_request_forgery","name":"javascript_express_server_side_request_forgery","shortDescription":{"text":"Unsanitized user input in HTTP request (SSRF)"},"fullDescription":{"text":"Unsanitized user input in HTTP request (SSRF)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncorporating unsanitized user input directly into URLs for data retrieval exposes your application to server-side request forgery (SSRF) attacks. This vulnerability arises when URLs include data provided by users without adequate validation or sanitization.\n\n## Remediations\n\n- **Do not** directly use user input to construct URLs for backend requests. This approach can lead to SSRF vulnerabilities.\n  ```javascript\n  axios.get(`https://${req.params.host}`); // unsafe\n  ```\n- **Do** validate or sanitize user input before using it in URLs. Prefer using a predefined list of allowed hosts and map user input to this list, ensuring only safe and expected URLs are constructed.\n  ```javascript\n  var host = \"default-api.com\"\n  if (req.params.host == \"something-else\") {\n    host = \"other-api.com\";\n  }\n\n  axios.get(`https://${host}`);\n  ```\n\n## References\n\n- [OWASP - Server-Side Request Forgery (SSRF) prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nIncorporating unsanitized user input directly into URLs for data retrieval exposes your application to server-side request forgery (SSRF) attacks. This vulnerability arises when URLs include data provided by users without adequate validation or sanitization.\n\n## Remediations\n\n- **Do not** directly use user input to construct URLs for backend requests. This approach can lead to SSRF vulnerabilities.\n  ```javascript\n  axios.get(`https://${req.params.host}`); // unsafe\n  ```\n- **Do** validate or sanitize user input before using it in URLs. Prefer using a predefined list of allowed hosts and map user input to this list, ensuring only safe and expected URLs are constructed.\n  ```javascript\n  var host = \"default-api.com\"\n  if (req.params.host == \"something-else\") {\n    host = \"other-api.com\";\n  }\n\n  axios.get(`https://${host}`);\n  ```\n\n## References\n\n- [OWASP - Server-Side Request Forgery (SSRF) prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)"}},{"id":"java_lang_weak_encryption_des","name":"java_lang_weak_encryption_des","shortDescription":{"text":"Usage of weak encryption algorithm (DES)"},"fullDescription":{"text":"Usage of weak encryption algorithm (DES)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour code is at risk due to the use of DES (Data Encryption Standard), a weak encryption algorithm. This vulnerability can lead to data breaches and compromises your security measures.\n\n## Remediations\n\n- **Do not** use DES as it is outdated and vulnerable to attacks. Its use can significantly weaken your application's security.\n- **Do** use stronger encryption algorithms to enhance data security. AES (Advanced Encryption Standard) is a recommended choice.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)","markdown":"## Description\n\nYour code is at risk due to the use of DES (Data Encryption Standard), a weak encryption algorithm. This vulnerability can lead to data breaches and compromises your security measures.\n\n## Remediations\n\n- **Do not** use DES as it is outdated and vulnerable to attacks. Its use can significantly weaken your application's security.\n- **Do** use stronger encryption algorithms to enhance data security. AES (Advanced Encryption Standard) is a recommended choice.\n  ```java\n  Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  ```\n\n## References\n\n- [Java Cipher class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/javax/crypto/Cipher.html)"}},{"id":"java_lang_file_upload_filename","name":"java_lang_file_upload_filename","shortDescription":{"text":"Unsanitized use of FileUpload filename"},"fullDescription":{"text":"Unsanitized use of FileUpload filename"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing the filename from FileUpload without sanitization can lead to path traversal attacks. This vulnerability occurs when an attacker manipulates the filename to access files or directories that are outside of the intended directory.\n\n## Remediations\n\n- **Do not** use unsanitized filenames from FileUpload directly. Attackers can exploit these filenames to navigate the server's directory structure.\n- **Do** sanitize user input when handling file paths. Use methods like `FilenameUtils.getName()` to ensure the path is safe and cannot be manipulated to traverse directories.\n  ```java\n  ServletFileUpload upload = new ServletFileUpload();\n  List\u003cFileItem\u003e fileItems = upload.parseRequest(request);\n\n  for (FileItem item : fileItems) {\n    String filename = FilenameUtils.getName(item.getName());\n    // ...\n  }\n  ```\n\n## References\n\n- [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)","markdown":"## Description\n\nUsing the filename from FileUpload without sanitization can lead to path traversal attacks. This vulnerability occurs when an attacker manipulates the filename to access files or directories that are outside of the intended directory.\n\n## Remediations\n\n- **Do not** use unsanitized filenames from FileUpload directly. Attackers can exploit these filenames to navigate the server's directory structure.\n- **Do** sanitize user input when handling file paths. Use methods like `FilenameUtils.getName()` to ensure the path is safe and cannot be manipulated to traverse directories.\n  ```java\n  ServletFileUpload upload = new ServletFileUpload();\n  List\u003cFileItem\u003e fileItems = upload.parseRequest(request);\n\n  for (FileItem item : fileItems) {\n    String filename = FilenameUtils.getName(item.getName());\n    // ...\n  }\n  ```\n\n## References\n\n- [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)"}},{"id":"java_spring_missing_session_fixation","name":"java_spring_missing_session_fixation","shortDescription":{"text":"Missing protection against session fixation attacks"},"fullDescription":{"text":"Missing protection against session fixation attacks"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nA session fixation attack is when an attacker sets a user's session ID to a known value before login. This can lead to unauthorized session hijacking. Spring framework, by default, protects against session fixation attacks by creating a new session or changing the user's session ID upon login. Disabling this default behaviour puts your application at increased risk of session fixation attacks.\n\n## Remediations\n\n- **Do not** disable Spring's default session fixation protection. Disabling it removes a critical layer of security.\n  ```java\n  http.sessionManagement().sessionFixation().none() // not recommended\n  ```\n- **Do** implement a session fixation protection strategy by configuring Spring to either create a new session or migrate to a new session ID upon login. This step is crucial for safeguarding user sessions against hijacking.\n  ```java\n  http.sessionManagement().sessionFixation().newSession() // or\n  http.sessionManagement().sessionFixation().migrateSession()\n  ```\n\n## References\n\n- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [Java Spring Session Fixation Configurer](https://docs.spring.io/spring-security/site/docs/5.1.x/api/org/springframework/security/config/annotation/web/configurers/SessionManagementConfigurer.SessionFixationConfigurer.html)\n","markdown":"## Description\n\nA session fixation attack is when an attacker sets a user's session ID to a known value before login. This can lead to unauthorized session hijacking. Spring framework, by default, protects against session fixation attacks by creating a new session or changing the user's session ID upon login. Disabling this default behaviour puts your application at increased risk of session fixation attacks.\n\n## Remediations\n\n- **Do not** disable Spring's default session fixation protection. Disabling it removes a critical layer of security.\n  ```java\n  http.sessionManagement().sessionFixation().none() // not recommended\n  ```\n- **Do** implement a session fixation protection strategy by configuring Spring to either create a new session or migrate to a new session ID upon login. This step is crucial for safeguarding user sessions against hijacking.\n  ```java\n  http.sessionManagement().sessionFixation().newSession() // or\n  http.sessionManagement().sessionFixation().migrateSession()\n  ```\n\n## References\n\n- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [Java Spring Session Fixation Configurer](https://docs.spring.io/spring-security/site/docs/5.1.x/api/org/springframework/security/config/annotation/web/configurers/SessionManagementConfigurer.SessionFixationConfigurer.html)\n"}},{"id":"java_lang_os_command_injection","name":"java_lang_os_command_injection","shortDescription":{"text":"Unsanitized user input in OS command"},"fullDescription":{"text":"Unsanitized user input in OS command"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nDirectly incorporating external or user-defined input into an OS command exposes the system to possible command injection attacks. This vulnerability allows attackers to execute unauthorized commands on the operating system, potentially leading to a compromise of system integrity.\n\n## Remediations\n\n- **Do not** use OS commands that include dynamic input directly. Instead, explore safer alternatives such as libraries or built-in functions that achieve the same goal without executing system commands.\n- **Do** use hardcoded values for any input that is incorporated into OS commands. This approach minimizes the risk by ensuring only predefined inputs are used, thus preventing attackers from injecting malicious commands.\n  ```java\n  String filePattern = \"*.json\";\n  if (\"xml\".equals(request.getParameter(\"format\"))) {\n    filePattern = \"*.xml\";\n  }\n\n  Process process = Runtime.getRuntime().exec(\"ls /myDir/\" + filePattern);\n  ```\n\n## References\n\n- [OWASP command injection explained](https://owasp.org/www-community/attacks/Command_Injection)","markdown":"## Description\n\nDirectly incorporating external or user-defined input into an OS command exposes the system to possible command injection attacks. This vulnerability allows attackers to execute unauthorized commands on the operating system, potentially leading to a compromise of system integrity.\n\n## Remediations\n\n- **Do not** use OS commands that include dynamic input directly. Instead, explore safer alternatives such as libraries or built-in functions that achieve the same goal without executing system commands.\n- **Do** use hardcoded values for any input that is incorporated into OS commands. This approach minimizes the risk by ensuring only predefined inputs are used, thus preventing attackers from injecting malicious commands.\n  ```java\n  String filePattern = \"*.json\";\n  if (\"xml\".equals(request.getParameter(\"format\"))) {\n    filePattern = \"*.xml\";\n  }\n\n  Process process = Runtime.getRuntime().exec(\"ls /myDir/\" + filePattern);\n  ```\n\n## References\n\n- [OWASP command injection explained](https://owasp.org/www-community/attacks/Command_Injection)"}},{"id":"javascript_third_parties_passport_hardcoded_secret","name":"javascript_third_parties_passport_hardcoded_secret","shortDescription":{"text":"Usage of hard-coded passport secret"},"fullDescription":{"text":"Usage of hard-coded passport secret"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nStoring secrets directly in your code, such as a passport authentication secret, is insecure. This practice makes your application vulnerable to attacks if the codebase is exposed.\n\n## Remediations\n\n- **Do not** hard-code secrets in your application code. Hard-coding makes sensitive information easily accessible to anyone who can view the code.\n  ```javascript\n  const strategy = new GoogleStrategy({ clientSecret: 'your_hardcoded_secret' }); // unsafe\n  passport.use(strategy);\n  ```\n- **Do** use environment variables to manage secrets securely. This method keeps sensitive information out of your codebase and makes it more difficult for unauthorized users to access.\n  ```javascript\n  const strategy = new GoogleStrategy({ clientSecret: process.env.GOOGLE_SECRET });\n  passport.use(strategy);\n  ```\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)","markdown":"## Description\n\nStoring secrets directly in your code, such as a passport authentication secret, is insecure. This practice makes your application vulnerable to attacks if the codebase is exposed.\n\n## Remediations\n\n- **Do not** hard-code secrets in your application code. Hard-coding makes sensitive information easily accessible to anyone who can view the code.\n  ```javascript\n  const strategy = new GoogleStrategy({ clientSecret: 'your_hardcoded_secret' }); // unsafe\n  passport.use(strategy);\n  ```\n- **Do** use environment variables to manage secrets securely. This method keeps sensitive information out of your codebase and makes it more difficult for unauthorized users to access.\n  ```javascript\n  const strategy = new GoogleStrategy({ clientSecret: process.env.GOOGLE_SECRET });\n  passport.use(strategy);\n  ```\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)"}},{"id":"javascript_lang_message_handler_origin","name":"javascript_lang_message_handler_origin","shortDescription":{"text":"Missing origin check in message handler"},"fullDescription":{"text":"Missing origin check in message handler"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nFailing to verify the origin of message events can expose your application to Cross-Site Scripting (XSS) attacks. This vulnerability arises when an application processes messages without confirming if they come from a trusted source.\n\n## Remediations\n\n- **Do not** add message event listeners without checking the origin of the messages. This approach leaves your application vulnerable to malicious inputs.\n  ```javascript\n  window.addEventListener('message', (event) =\u003e {\n    actOnMessage(event.data) // unsafe\n  })\n  ```\n- **Do** validate the origin of incoming messages before processing them. Ensure that the message comes from a trusted source by comparing the event's origin with a predefined list of allowed origins.\n  ```javascript\n  window.addEventListener('message', (event) =\u003e {\n    if (event.origin != 'https://myapp.example.com') {\n      throw new Error('invalid origin')\n    }\n\n    actOnMessage(event.data)\n  })\n  ```\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nFailing to verify the origin of message events can expose your application to Cross-Site Scripting (XSS) attacks. This vulnerability arises when an application processes messages without confirming if they come from a trusted source.\n\n## Remediations\n\n- **Do not** add message event listeners without checking the origin of the messages. This approach leaves your application vulnerable to malicious inputs.\n  ```javascript\n  window.addEventListener('message', (event) =\u003e {\n    actOnMessage(event.data) // unsafe\n  })\n  ```\n- **Do** validate the origin of incoming messages before processing them. Ensure that the message comes from a trusted source by comparing the event's origin with a predefined list of allowed origins.\n  ```javascript\n  window.addEventListener('message', (event) =\u003e {\n    if (event.origin != 'https://myapp.example.com') {\n      throw new Error('invalid origin')\n    }\n\n    actOnMessage(event.data)\n  })\n  ```\n\n## References\n\n- [OWASP Cross-Site Scripting (XSS) Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)"}},{"id":"java_lang_permissive_allow_origin","name":"java_lang_permissive_allow_origin","shortDescription":{"text":"Permissive Access-Control-Allow-Origin configuration"},"fullDescription":{"text":"Permissive Access-Control-Allow-Origin configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nA permissive Access-Control-Allow-Origin configuration can expose your application to security risks. When this header is set to \"*\", it means your application's responses can be accessed by any website, potentially leading to unauthorized access to sensitive information.\n\n## Remediations\n\n- **Do not** set the Access-Control-Allow-Origin header to \"*\". This overly permissive setting can make your application vulnerable to attacks.\n  ```java\n    response.addHeader(\"access-control-allow-origin\", \"*\"); // unsafe\n  ```\n- **Do** restrict the Access-Control-Allow-Origin header to only allow specific, trusted origins that need access to your application. This minimizes the risk of sensitive data exposure.\n  ```java\n  response.addHeader(\"access-control-allow-origin\", \"myapp.example.com\");\n  ```\n\n## References\n\n- [OWASP Origin \u0026 Access-Control-Allow-Origin](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing)","markdown":"## Description\n\nA permissive Access-Control-Allow-Origin configuration can expose your application to security risks. When this header is set to \"*\", it means your application's responses can be accessed by any website, potentially leading to unauthorized access to sensitive information.\n\n## Remediations\n\n- **Do not** set the Access-Control-Allow-Origin header to \"*\". This overly permissive setting can make your application vulnerable to attacks.\n  ```java\n    response.addHeader(\"access-control-allow-origin\", \"*\"); // unsafe\n  ```\n- **Do** restrict the Access-Control-Allow-Origin header to only allow specific, trusted origins that need access to your application. This minimizes the risk of sensitive data exposure.\n  ```java\n  response.addHeader(\"access-control-allow-origin\", \"myapp.example.com\");\n  ```\n\n## References\n\n- [OWASP Origin \u0026 Access-Control-Allow-Origin](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing)"}},{"id":"javascript_lang_weak_encryption_rc4","name":"javascript_lang_weak_encryption_rc4","shortDescription":{"text":"Usage of weak encryption algorithm (RC4)"},"fullDescription":{"text":"Usage of weak encryption algorithm (RC4)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing the RC4 (Rivest Cipher 4) encryption algorithm introduces a significant security vulnerability. RC4 is outdated and has been proven to be susceptible to various attacks, making any data encrypted with it vulnerable to unauthorized access and compromise.\n\n## Remediations\n\n- **Do not** use RC4 for encrypting data. Its weaknesses can lead to compromised data security.\n- **Do** opt for stronger, more secure encryption algorithms like AES-256 when encrypting data. This ensures a higher level of security for your data.\n  ```javascript\n  const crypto = require(\"crypto\");\n\n  const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);\n  const encrypted = cipher.update(\"my secret message\", \"utf8\");\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)","markdown":"## Description\n\nUsing the RC4 (Rivest Cipher 4) encryption algorithm introduces a significant security vulnerability. RC4 is outdated and has been proven to be susceptible to various attacks, making any data encrypted with it vulnerable to unauthorized access and compromise.\n\n## Remediations\n\n- **Do not** use RC4 for encrypting data. Its weaknesses can lead to compromised data security.\n- **Do** opt for stronger, more secure encryption algorithms like AES-256 when encrypting data. This ensures a higher level of security for your data.\n  ```javascript\n  const crypto = require(\"crypto\");\n\n  const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);\n  const encrypted = cipher.update(\"my secret message\", \"utf8\");\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)"}},{"id":"java_lang_logger_leak","name":"java_lang_logger_leak","shortDescription":{"text":"Leakage of information in logger message"},"fullDescription":{"text":"Leakage of information in logger message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nInformation leakage through logger messages can compromise sensitive data. This vulnerability arises when dynamic data or variables, which may contain sensitive information, are included in log messages.\n\n## Remediations\n\n- **Do not** include variables or dynamic data containing sensitive information in logger messages. This can inadvertently expose sensitive data in logs, which are often not adequately protected.\n  ```java\n  logger.info(\"user signed in: \" + user.uuid) // unsafe\n  ```\n- **Do** log static messages that do not contain dynamic variables or attributes. This minimizes the risk of accidentally logging sensitive information.\n  ```java\n  logger.info(\"user signed in\")\n  ```\n\n## References\n\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)","markdown":"## Description\n\nInformation leakage through logger messages can compromise sensitive data. This vulnerability arises when dynamic data or variables, which may contain sensitive information, are included in log messages.\n\n## Remediations\n\n- **Do not** include variables or dynamic data containing sensitive information in logger messages. This can inadvertently expose sensitive data in logs, which are often not adequately protected.\n  ```java\n  logger.info(\"user signed in: \" + user.uuid) // unsafe\n  ```\n- **Do** log static messages that do not contain dynamic variables or attributes. This minimizes the risk of accidentally logging sensitive information.\n  ```java\n  logger.info(\"user signed in\")\n  ```\n\n## References\n\n- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)"}},{"id":"java_lang_insecure_allow_origin","name":"java_lang_insecure_allow_origin","shortDescription":{"text":"Unsanitized user input in Access-Control-Allow-Origin"},"fullDescription":{"text":"Unsanitized user input in Access-Control-Allow-Origin"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unverified user-defined input to set the Access-Control-Allow-Origin header can result in unauthorized access to sensitive data. This vulnerability exposes your application to potential security risks by allowing attackers to specify origins that can access resources.\n\n## Remediations\n\n- **Do not** use user input to define the `Access-Control-Allow-Origin` header without validation. This practice can inadvertently grant access to sensitive information.\n- **Do** verify user input if it is absolutely necessary to use it for defining origins. Implement a mechanism to ensure the input is from a trusted source.\n- **Do** use a safelist approach when specifying origins. Only allow known, trusted domains to interact with your resources.\n\n## References\n\n- [OWASP Origin \u0026 Access-Control-Allow-Origin](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing)","markdown":"## Description\n\nUsing unverified user-defined input to set the Access-Control-Allow-Origin header can result in unauthorized access to sensitive data. This vulnerability exposes your application to potential security risks by allowing attackers to specify origins that can access resources.\n\n## Remediations\n\n- **Do not** use user input to define the `Access-Control-Allow-Origin` header without validation. This practice can inadvertently grant access to sensitive information.\n- **Do** verify user input if it is absolutely necessary to use it for defining origins. Implement a mechanism to ensure the input is from a trusted source.\n- **Do** use a safelist approach when specifying origins. Only allow known, trusted domains to interact with your resources.\n\n## References\n\n- [OWASP Origin \u0026 Access-Control-Allow-Origin](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing)"}},{"id":"java_lang_log_injection","name":"java_lang_log_injection","shortDescription":{"text":"Unsanitized user input in logger message"},"fullDescription":{"text":"Unsanitized user input in logger message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLogging unsanitized user input can lead to log forgery or malicious content injection. This vulnerability arises when user input is directly included in log messages without proper sanitization.\n\n## Remediations\n\n- **Do not** include unsanitized user input in log messages. This can allow attackers to manipulate log files or inject harmful content.\n  ```java\n  String username = request.getParameter(\"username\");\n  log.warn(\"Username is\" + username); // unsafe\n  ```\n- **Do** sanitize user input before logging it. Ensure that any data derived from user input is cleaned to prevent log injection attacks.\n  ```java\n  String username = sanitized(request.getParameter(\"username\"));\n  log.warn(\"Username is\" + username);\n  ```\n## References\n\n- [OWASP Log Injection](https://owasp.org/www-community/attacks/Log_Injection)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)","markdown":"## Description\n\nLogging unsanitized user input can lead to log forgery or malicious content injection. This vulnerability arises when user input is directly included in log messages without proper sanitization.\n\n## Remediations\n\n- **Do not** include unsanitized user input in log messages. This can allow attackers to manipulate log files or inject harmful content.\n  ```java\n  String username = request.getParameter(\"username\");\n  log.warn(\"Username is\" + username); // unsafe\n  ```\n- **Do** sanitize user input before logging it. Ensure that any data derived from user input is cleaned to prevent log injection attacks.\n  ```java\n  String username = sanitized(request.getParameter(\"username\"));\n  log.warn(\"Username is\" + username);\n  ```\n## References\n\n- [OWASP Log Injection](https://owasp.org/www-community/attacks/Log_Injection)\n- [OWASP logging cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)"}},{"id":"java_lang_information_leakage","name":"java_lang_information_leakage","shortDescription":{"text":"Leakage of sensitive information in exception message"},"fullDescription":{"text":"Leakage of sensitive information in exception message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeakage of sensitive information in exception messages poses a significant security risk. When an exception message is printed to the default output, it might reveal sensitive details about your application's technical setup or environment. This could potentially open the door to attacks, such as path traversal. Even more concerning is the possibility of exposing user-specific data, which could lead to serious privacy breaches.\n\n## Remediations\n\n- **Do not** print the full stack trace to the default output. This can inadvertently reveal sensitive information.\n  ```java\n  System.out.println(e); // unsafe\n  ```\n- **Do** limit error messages to only include the necessary information for understanding the issue without exposing sensitive data.\n  ```java\n  System.out.println(\"An error occurred. Please try again.\");\n  ```\n\n## References\n\n- [Web Application Security Consortium: Information Leakage](http://projects.webappsec.org/w/page/13246936/Information%20Leakage)","markdown":"## Description\n\nLeakage of sensitive information in exception messages poses a significant security risk. When an exception message is printed to the default output, it might reveal sensitive details about your application's technical setup or environment. This could potentially open the door to attacks, such as path traversal. Even more concerning is the possibility of exposing user-specific data, which could lead to serious privacy breaches.\n\n## Remediations\n\n- **Do not** print the full stack trace to the default output. This can inadvertently reveal sensitive information.\n  ```java\n  System.out.println(e); // unsafe\n  ```\n- **Do** limit error messages to only include the necessary information for understanding the issue without exposing sensitive data.\n  ```java\n  System.out.println(\"An error occurred. Please try again.\");\n  ```\n\n## References\n\n- [Web Application Security Consortium: Information Leakage](http://projects.webappsec.org/w/page/13246936/Information%20Leakage)"}},{"id":"javascript_lang_import_using_user_input","name":"javascript_lang_import_using_user_input","shortDescription":{"text":"Usage of externally controlled input to select code"},"fullDescription":{"text":"Usage of externally controlled input to select code"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLoading code dynamically from a path dictated by user input can allow attackers to execute arbitrary code on your system.\n\n## Remediations\n\n- **Do not** pass user or request input directly to the `require()` function. This practice can lead to severe security vulnerabilities.\n- **Do** sanitize user input if it must be used to dynamically load code. Ensure that the input is checked and cleaned to prevent malicious data from being processed.\n- **Do** use a safelist approach when relying on user input to load code dynamically. Verify that the input matches a predefined list of safe values before processing.\n  ```javascript\n  var path = req.body.path;\n  if (['users', 'posts', 'pages'].includes(path)) {\n    require(`${path}.js`);\n  }\n  ```","markdown":"## Description\n\nLoading code dynamically from a path dictated by user input can allow attackers to execute arbitrary code on your system.\n\n## Remediations\n\n- **Do not** pass user or request input directly to the `require()` function. This practice can lead to severe security vulnerabilities.\n- **Do** sanitize user input if it must be used to dynamically load code. Ensure that the input is checked and cleaned to prevent malicious data from being processed.\n- **Do** use a safelist approach when relying on user input to load code dynamically. Verify that the input matches a predefined list of safe values before processing.\n  ```javascript\n  var path = req.body.path;\n  if (['users', 'posts', 'pages'].includes(path)) {\n    require(`${path}.js`);\n  }\n  ```"}},{"id":"javascript_express_path_traversal","name":"javascript_express_path_traversal","shortDescription":{"text":"Unsanitized user input in file path"},"fullDescription":{"text":"Unsanitized user input in file path"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input to construct file paths can allow attackers to access files and directories beyond the intended limits. This vulnerability, known as path traversal, poses a significant security risk.\n\n## Remediations\n\n- **Do not** directly use user input in file path construction. This can lead to unauthorized file access.\n- **Do** sanitize user input before using it in path resolution. Replace or remove dangerous patterns like `\\..\\..` to prevent directory traversal attacks.\n  ```javascript\n  var sanitizedPath = userInput.replace(/^(\\.\\.(\\/|\\\\|$))+/, '');\n  ```\n- **Do** check for and eliminate any instances of the poison NULL byte (\"%00\") in user input, as it can be used to bypass path sanitization.\n  ```javascript\n  if (userInput.indexOf('\\0') !== -1) {\n    // Handle or reject the input\n  }\n  ```\n- **Do** validate the final path to ensure it is within the intended scope before accessing the file system.\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)","markdown":"## Description\n\nUsing unsanitized user input to construct file paths can allow attackers to access files and directories beyond the intended limits. This vulnerability, known as path traversal, poses a significant security risk.\n\n## Remediations\n\n- **Do not** directly use user input in file path construction. This can lead to unauthorized file access.\n- **Do** sanitize user input before using it in path resolution. Replace or remove dangerous patterns like `\\..\\..` to prevent directory traversal attacks.\n  ```javascript\n  var sanitizedPath = userInput.replace(/^(\\.\\.(\\/|\\\\|$))+/, '');\n  ```\n- **Do** check for and eliminate any instances of the poison NULL byte (\"%00\") in user input, as it can be used to bypass path sanitization.\n  ```javascript\n  if (userInput.indexOf('\\0') !== -1) {\n    // Handle or reject the input\n  }\n  ```\n- **Do** validate the final path to ensure it is within the intended scope before accessing the file system.\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)"}},{"id":"javascript_lang_open_redirect","name":"javascript_lang_open_redirect","shortDescription":{"text":"Unsanitized user input in redirect"},"fullDescription":{"text":"Unsanitized user input in redirect"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input in redirects increases the risk of phishing attacks. This vulnerability occurs when an application dynamically redirects users to a URL that includes user-controlled input without proper validation or sanitization.\n\n## Remediations\n\n- **Do not** directly use user input in redirect URLs. This can lead to phishing attacks where attackers can redirect users to malicious sites.\n- **Do** validate and sanitize all user input used in redirects. Ensure that the destination URLs are safe and intended. Use a whitelist of allowed URLs if possible.\n- **Do** use server-side redirection methods that do not allow user input to directly influence the destination. This ensures that the application controls the redirect targets.\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)","markdown":"## Description\n\nUsing unsanitized user input in redirects increases the risk of phishing attacks. This vulnerability occurs when an application dynamically redirects users to a URL that includes user-controlled input without proper validation or sanitization.\n\n## Remediations\n\n- **Do not** directly use user input in redirect URLs. This can lead to phishing attacks where attackers can redirect users to malicious sites.\n- **Do** validate and sanitize all user input used in redirects. Ensure that the destination URLs are safe and intended. Use a whitelist of allowed URLs if possible.\n- **Do** use server-side redirection methods that do not allow user input to directly influence the destination. This ensures that the application controls the redirect targets.\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)"}},{"id":"java_spring_model_reflected_xss","name":"java_spring_model_reflected_xss","shortDescription":{"text":"Unsanitized request data in Spring UI model (XSS)"},"fullDescription":{"text":"Unsanitized request data in Spring UI model (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nCross-site scripting (XSS) vulnerabilities occur when unsanitized user input is included in web page content. This flaw can lead to malicious scripts being executed in the context of the user's browser, compromising the security of user data and interactions with the application.\n\n## Remediations\n\n- **Do** validate the input before adding it to the UI model.\n- **Do** sanitize user input to remove or neutralize unwanted scripts.\n\n## References\n\n- [OWASP XSS Prevention Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP Java Encoder](https://owasp.org/www-project-java-encoder/)\n- [Spring HtmlUtils](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/HtmlUtils.html)","markdown":"## Description\n\nCross-site scripting (XSS) vulnerabilities occur when unsanitized user input is included in web page content. This flaw can lead to malicious scripts being executed in the context of the user's browser, compromising the security of user data and interactions with the application.\n\n## Remediations\n\n- **Do** validate the input before adding it to the UI model.\n- **Do** sanitize user input to remove or neutralize unwanted scripts.\n\n## References\n\n- [OWASP XSS Prevention Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP Java Encoder](https://owasp.org/www-project-java-encoder/)\n- [Spring HtmlUtils](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/HtmlUtils.html)"}},{"id":"javascript_lang_weak_encryption_des","name":"javascript_lang_weak_encryption_des","shortDescription":{"text":"Usage of weak encryption algorithm (DES)"},"fullDescription":{"text":"Usage of weak encryption algorithm (DES)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour code is at risk due to the use of DES (Data Encryption Standard), a weak encryption algorithm. This vulnerability can lead to data breaches and compromises your security measures.\n\n## Remediations\n\n- **Do not** use DES as it is outdated and vulnerable to attacks. Its use can significantly weaken your application's security.\n- **Do** opt for stronger encryption algorithms, such as AES (Advanced Encryption Standard), to ensure the confidentiality and integrity of your data.\n  ```javascript\n  const crypto = require(\"crypto\");\n\n  const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);\n  const encrypted = cipher.update(\"my secret message\", \"utf8\");\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)","markdown":"## Description\n\nYour code is at risk due to the use of DES (Data Encryption Standard), a weak encryption algorithm. This vulnerability can lead to data breaches and compromises your security measures.\n\n## Remediations\n\n- **Do not** use DES as it is outdated and vulnerable to attacks. Its use can significantly weaken your application's security.\n- **Do** opt for stronger encryption algorithms, such as AES (Advanced Encryption Standard), to ensure the confidentiality and integrity of your data.\n  ```javascript\n  const crypto = require(\"crypto\");\n\n  const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);\n  const encrypted = cipher.update(\"my secret message\", \"utf8\");\n  ```\n\n## References\n\n- [NodeJS Crypto Module](https://nodejs.org/api/crypto.html)"}},{"id":"java_lang_weak_hash_sha1","name":"java_lang_weak_hash_sha1","shortDescription":{"text":"Usage of weak hashing library (SHA-1)"},"fullDescription":{"text":"Usage of weak hashing library (SHA-1)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing a weak hashing library like SHA-1 increases the risk of data breaches. SHA-1 in particular is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing. It is no longer considered secure.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); // unsafe\n  ```\n- **Do** use stronger hashing algorithms such as SHA-256 to enhance security.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)","markdown":"## Description\n\nUsing a weak hashing library like SHA-1 increases the risk of data breaches. SHA-1 in particular is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use SHA-1 for hashing. It is no longer considered secure.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); // unsafe\n  ```\n- **Do** use stronger hashing algorithms such as SHA-256 to enhance security.\n  ```java\n  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n  ```\n\n## References\n\n- [Java MessageDigest class](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/security/MessageDigest.html)"}},{"id":"java_lang_format_string_manipulation","name":"java_lang_format_string_manipulation","shortDescription":{"text":"Unsanitized user input in format string detected"},"fullDescription":{"text":"Unsanitized user input in format string detected"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input as the format string in format functions exposes your application to potential attacks. This vulnerability allows attackers to craft format strings that can lead to unauthorized data exposure or cause your application to crash.\n\n## Remediations\n\n- **Do not** use user input directly as the format string in formatting functions. This applies to any situation where the first argument (or second, if a locale is specified) is expected to be a format string.\n  ```java\n  String.format(request.getParameter(\"foo\"), \"bar\"); // unsafe\n  String.format(Locale.US, request.getParameter(\"foo\"), \"bar\"); // unsafe\n  ```\n- **Do** use hard-coded format strings when working with formatting functions. This ensures that the format string is not influenced by external input, mitigating the risk of format string vulnerabilities.\n  ```java\n  String.format(\"Strings: %s\", request.getParameter(\"foo\"), \"bar\");\n  String.format(Locale.US, \"Strings: %s\", request.getParameter(\"foo\"), \"bar\");\n  ```\n\n## References\n\n- [OWASP Testing for Format String Injection](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/13-Testing_for_Format_String_Injection)","markdown":"## Description\n\nUsing unsanitized user input as the format string in format functions exposes your application to potential attacks. This vulnerability allows attackers to craft format strings that can lead to unauthorized data exposure or cause your application to crash.\n\n## Remediations\n\n- **Do not** use user input directly as the format string in formatting functions. This applies to any situation where the first argument (or second, if a locale is specified) is expected to be a format string.\n  ```java\n  String.format(request.getParameter(\"foo\"), \"bar\"); // unsafe\n  String.format(Locale.US, request.getParameter(\"foo\"), \"bar\"); // unsafe\n  ```\n- **Do** use hard-coded format strings when working with formatting functions. This ensures that the format string is not influenced by external input, mitigating the risk of format string vulnerabilities.\n  ```java\n  String.format(\"Strings: %s\", request.getParameter(\"foo\"), \"bar\");\n  String.format(Locale.US, \"Strings: %s\", request.getParameter(\"foo\"), \"bar\");\n  ```\n\n## References\n\n- [OWASP Testing for Format String Injection](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/13-Testing_for_Format_String_Injection)"}},{"id":"java_lang_reflection_using_user_input","name":"java_lang_reflection_using_user_input","shortDescription":{"text":"Usage of external input in code reflection"},"fullDescription":{"text":"Usage of external input in code reflection"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing external input for dynamic class loading or code execution through reflection poses a significant security risk. This practice can be exploited by attackers to load harmful classes or execute malicious methods, potentially resulting in remote code execution and other severe security threats.\n\n## Remediations\n\n- **Do not** - wherever possible - use external input with code reflection. Avoiding this practice altogether significantly lowers the risk of executing unauthorized or malicious code.\n- **Do** limit the allowed class names and method names to a predefined safelist. This approach restricts the scope of classes and methods that can be dynamically accessed, reducing the risk of unauthorized actions.\n- **Do** sanitize external input by removing special and unexpected characters that could facilitate code injection attacks. Characters such as single or double quotation marks and backslashes are particularly risky and should be filtered out.","markdown":"## Description\n\nUsing external input for dynamic class loading or code execution through reflection poses a significant security risk. This practice can be exploited by attackers to load harmful classes or execute malicious methods, potentially resulting in remote code execution and other severe security threats.\n\n## Remediations\n\n- **Do not** - wherever possible - use external input with code reflection. Avoiding this practice altogether significantly lowers the risk of executing unauthorized or malicious code.\n- **Do** limit the allowed class names and method names to a predefined safelist. This approach restricts the scope of classes and methods that can be dynamically accessed, reducing the risk of unauthorized actions.\n- **Do** sanitize external input by removing special and unexpected characters that could facilitate code injection attacks. Characters such as single or double quotation marks and backslashes are particularly risky and should be filtered out."}},{"id":"java_lang_xml_external_entity_vulnerability","name":"java_lang_xml_external_entity_vulnerability","shortDescription":{"text":"Unsanitized user input in XML External Entity"},"fullDescription":{"text":"Unsanitized user input in XML External Entity"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nAvoid parsing untrusted data such as user input as XML. Such data could include URIs that resolve to resources that are outside of the current context, leading to XML External Entity (XXE) injection. XXE injection arises when XML input containing a reference to an external entity is processed without proper sanitization, potentially allowing attackers to access internal files, cause denial of service, or execute remote code.\n\n## Remediations\n\n- **Do not** parse XML input with external entity processing enabled. This prevents attackers from exploiting XXE vulnerabilities.\n\n## References\n\n- [OWASP XML External Entity (XXE) prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)","markdown":"## Description\n\nAvoid parsing untrusted data such as user input as XML. Such data could include URIs that resolve to resources that are outside of the current context, leading to XML External Entity (XXE) injection. XXE injection arises when XML input containing a reference to an external entity is processed without proper sanitization, potentially allowing attackers to access internal files, cause denial of service, or execute remote code.\n\n## Remediations\n\n- **Do not** parse XML input with external entity processing enabled. This prevents attackers from exploiting XXE vulnerabilities.\n\n## References\n\n- [OWASP XML External Entity (XXE) prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)"}},{"id":"java_lang_external_config_control","name":"java_lang_external_config_control","shortDescription":{"text":"Unsanitized user input in SQL catalog configuration"},"fullDescription":{"text":"Unsanitized user input in SQL catalog configuration"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing unsanitized user input to configure a SQL Connection's catalog can lead to security vulnerabilities. This practice allows attackers to manipulate the catalog name in the `setCatalog` method, potentially causing harmful or unintended actions in the application.\n\n## Remediations\n\n- **Do not** use direct user input for setting the SQL database's catalog. Always sanitize or validate input before using it in your database configuration.\n\n## References\n\n- [Java SQL Connection](https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/Connection.html)","markdown":"## Description\n\nUsing unsanitized user input to configure a SQL Connection's catalog can lead to security vulnerabilities. This practice allows attackers to manipulate the catalog name in the `setCatalog` method, potentially causing harmful or unintended actions in the application.\n\n## Remediations\n\n- **Do not** use direct user input for setting the SQL database's catalog. Always sanitize or validate input before using it in your database configuration.\n\n## References\n\n- [Java SQL Connection](https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/Connection.html)"}},{"id":"javascript_lang_dynamic_os_command","name":"javascript_lang_dynamic_os_command","shortDescription":{"text":"Unsanitized dynamic input in OS command"},"fullDescription":{"text":"Unsanitized dynamic input in OS command"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nIncorporating unsanitized dynamic input directly into operating system commands poses a significant security risk. This practice could give attackers the opportunity to execute harmful commands on your system.\n\n## Remediations\n\n- **Do** use static, hardcoded values in command strings - wherever possible - to avoid relying on dynamic data.\n  ```javascript\n  let filePattern = \"*.js\";\n  cp.exec(`cp ${filePattern} destinationFolder`, (error, stdout, stderr) =\u003e {});\n  ```\n- **Do** sanitize any dynamic input used in OS commands to ensure it does not contain malicious code. This can be achieved by validating and escaping the input.\n\n## References\n\n- [OWASP command injection explained](https://owasp.org/www-community/attacks/Command_Injection)","markdown":"## Description\n\nIncorporating unsanitized dynamic input directly into operating system commands poses a significant security risk. This practice could give attackers the opportunity to execute harmful commands on your system.\n\n## Remediations\n\n- **Do** use static, hardcoded values in command strings - wherever possible - to avoid relying on dynamic data.\n  ```javascript\n  let filePattern = \"*.js\";\n  cp.exec(`cp ${filePattern} destinationFolder`, (error, stdout, stderr) =\u003e {});\n  ```\n- **Do** sanitize any dynamic input used in OS commands to ensure it does not contain malicious code. This can be achieved by validating and escaping the input.\n\n## References\n\n- [OWASP command injection explained](https://owasp.org/www-community/attacks/Command_Injection)"}},{"id":"javascript_third_parties_dom_purify","name":"javascript_third_parties_dom_purify","shortDescription":{"text":"Usage of vulnerable DOMPurify package"},"fullDescription":{"text":"Usage of vulnerable DOMPurify package"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nFor DOMPurify versions less than 2.0.17, there are XSS vulnerabilities when using the sanitize function without proper configuration.\n\n## Remediations\n\n- **Do** upgrade DOMPurify to version 2.0.17 or greater, and specify a secure configuration option.\n  ```javascript\n    // either\n    DOMPurify.sanitize(htmlToSanitize, { RETURN_DOM_IMPORT:true })\n    // or\n    DOMPurify.sanitize(htmlToSanitize, { RETURN_DOM_FRAGMENT: true })\n  ```\n\n## References\n- [Vulnerability explained](https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass)\n","markdown":"## Description\n\nFor DOMPurify versions less than 2.0.17, there are XSS vulnerabilities when using the sanitize function without proper configuration.\n\n## Remediations\n\n- **Do** upgrade DOMPurify to version 2.0.17 or greater, and specify a secure configuration option.\n  ```javascript\n    // either\n    DOMPurify.sanitize(htmlToSanitize, { RETURN_DOM_IMPORT:true })\n    // or\n    DOMPurify.sanitize(htmlToSanitize, { RETURN_DOM_FRAGMENT: true })\n  ```\n\n## References\n- [Vulnerability explained](https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass)\n"}},{"id":"javascript_lang_file_generation","name":"javascript_lang_file_generation","shortDescription":{"text":"Leakage of sensitive data in dynamic file generation"},"fullDescription":{"text":"Leakage of sensitive data in dynamic file generation"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nSensitive data leakage in dynamic file generation occurs when sensitive information is written to static files such as logs, backups, or data exports. This vulnerability exposes sensitive data to unauthorized access.\n\n## Remediations\n\n- **Do not** write sensitive data directly to logs, backups, or data exports. This practice can lead to unauthorized access to sensitive information.\n  ```javascript\n  fs.writeFile(\"data.csv\", JSON.stringify(users), \"utf-8\", (err) =\u003e {\n    if (err) console.log(err)\n  })\n  ```\n- **Do** obfuscate or filter sensitive data before writing it to static files. This reduces the risk of sensitive data exposure.","markdown":"## Description\n\nSensitive data leakage in dynamic file generation occurs when sensitive information is written to static files such as logs, backups, or data exports. This vulnerability exposes sensitive data to unauthorized access.\n\n## Remediations\n\n- **Do not** write sensitive data directly to logs, backups, or data exports. This practice can lead to unauthorized access to sensitive information.\n  ```javascript\n  fs.writeFile(\"data.csv\", JSON.stringify(users), \"utf-8\", (err) =\u003e {\n    if (err) console.log(err)\n  })\n  ```\n- **Do** obfuscate or filter sensitive data before writing it to static files. This reduces the risk of sensitive data exposure."}},{"id":"java_lang_xss_response_writer","name":"java_lang_xss_response_writer","shortDescription":{"text":"Unsanitized user input in output stream (XSS)"},"fullDescription":{"text":"Unsanitized user input in output stream (XSS)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nCross-site scripting (XSS) vulnerabilities occur when unsanitized user input is included in web page content. This flaw can lead to malicious scripts being executed in the context of the user's browser, compromising the security of user data and interactions with the application.\n\n## Remediations\n\n- **Do** use an encoder to handle user input before incorporating it into the output stream. This step helps minimize the risk of XSS attacks by converting potentially dangerous characters into a safe format.\n  ```java\n  String userInput = req.getQueryString(\"user\");\n  String encodedUserInput = Encode.forHtml(userInput);\n  response.getWriter().write(encodedUserInput);\n  ```\n- **Do** sanitize user input to remove or neutralize unwanted scripts. Sanitization goes beyond encoding by actively removing harmful content from user input before it is used in the output.\n  ```java\n  String userInput = req.getQueryString(\"user\");\n  String sanitizedUserInput = sanitize(userInput);\n  response.getWriter().write(sanitizedUserInput);\n  ```\n\n## References\n\n- [OWASP XSS Prevention Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP Java Encoder](https://owasp.org/www-project-java-encoder/)","markdown":"## Description\n\nCross-site scripting (XSS) vulnerabilities occur when unsanitized user input is included in web page content. This flaw can lead to malicious scripts being executed in the context of the user's browser, compromising the security of user data and interactions with the application.\n\n## Remediations\n\n- **Do** use an encoder to handle user input before incorporating it into the output stream. This step helps minimize the risk of XSS attacks by converting potentially dangerous characters into a safe format.\n  ```java\n  String userInput = req.getQueryString(\"user\");\n  String encodedUserInput = Encode.forHtml(userInput);\n  response.getWriter().write(encodedUserInput);\n  ```\n- **Do** sanitize user input to remove or neutralize unwanted scripts. Sanitization goes beyond encoding by actively removing harmful content from user input before it is used in the output.\n  ```java\n  String userInput = req.getQueryString(\"user\");\n  String sanitizedUserInput = sanitize(userInput);\n  response.getWriter().write(sanitizedUserInput);\n  ```\n\n## References\n\n- [OWASP XSS Prevention Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP Java Encoder](https://owasp.org/www-project-java-encoder/)"}},{"id":"java_lang_path_traversal","name":"java_lang_path_traversal","shortDescription":{"text":"Unsanitized user input in file path"},"fullDescription":{"text":"Unsanitized user input in file path"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUnsanitized user input in file paths can compromise your system's security. This vulnerability arises when user input is directly used to construct file names or paths without proper sanitization, potentially leading to path manipulation. Attackers could exploit this to access files or directories outside the intended scope, posing a significant security risk.\n\n## Remediations\n\n- **Do not** construct file paths directly with user input. This practice can inadvertently allow attackers to manipulate paths to access unauthorized files.\n- **Do** use path normalization utilities to safely handle user input in file paths. These utilities help eliminate dangerous path sequences.\n  ```java\n  public class Cls extends HttpServlet\n  {\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String image = request.getParameter(\"user_profile_picture\");\n\n          // normalize path\n          Path imagePath = Paths.get(\"user/profile/\" + FilenameUtils.getName(image)).normalize();\n          File file = new File(imagePath.toString());\n      }\n  }\n  ```\n\n## References\n\n- [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)","markdown":"## Description\n\nUnsanitized user input in file paths can compromise your system's security. This vulnerability arises when user input is directly used to construct file names or paths without proper sanitization, potentially leading to path manipulation. Attackers could exploit this to access files or directories outside the intended scope, posing a significant security risk.\n\n## Remediations\n\n- **Do not** construct file paths directly with user input. This practice can inadvertently allow attackers to manipulate paths to access unauthorized files.\n- **Do** use path normalization utilities to safely handle user input in file paths. These utilities help eliminate dangerous path sequences.\n  ```java\n  public class Cls extends HttpServlet\n  {\n      public void handleRequest(HttpServletRequest request, HttpServletResponse response)\n      {\n          String image = request.getParameter(\"user_profile_picture\");\n\n          // normalize path\n          Path imagePath = Paths.get(\"user/profile/\" + FilenameUtils.getName(image)).normalize();\n          File file = new File(imagePath.toString());\n      }\n  }\n  ```\n\n## References\n\n- [OWASP path traversal](https://owasp.org/www-community/attacks/Path_Traversal)"}},{"id":"java_third_parties_clickhouse","name":"java_third_parties_clickhouse","shortDescription":{"text":"Leakage of sensitive data to ClickHouse"},"fullDescription":{"text":"Leakage of sensitive data to ClickHouse"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to a third-party service like ClickHouse is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like ClickHouse.\n\n## References\n- [ClickHouse docs](https://clickhouse.com/docs/en/intro/)\n","markdown":"## Description\n\nLeaking sensitive data to a third-party service like ClickHouse is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like ClickHouse.\n\n## References\n- [ClickHouse docs](https://clickhouse.com/docs/en/intro/)\n"}},{"id":"java_third_parties_algolia","name":"java_third_parties_algolia","shortDescription":{"text":"Leakage of sensitive data to Algolia"},"fullDescription":{"text":"Leakage of sensitive data to Algolia"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nLeaking sensitive data to third-party data tools like Algolia is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like Algolia.\n\n## References\n- [Algolia docs](https://www.algolia.com/doc/)\n","markdown":"## Description\n\nLeaking sensitive data to third-party data tools like Algolia is a common cause of data leaks and can lead to data breaches.\n\n## Remediations\n\n- **Do** ensure all sensitive data is removed when sending data to third-party services like Algolia.\n\n## References\n- [Algolia docs](https://www.algolia.com/doc/)\n"}},{"id":"java_lang_bad_hex_conversion","name":"java_lang_bad_hex_conversion","shortDescription":{"text":"Usage of bad hex conversion on digest array"},"fullDescription":{"text":"Usage of bad hex conversion on digest array"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nYour application is using `Integer.toHexString` for converting a digest array buffer into a hexadecimal string, which may lead to incorrect representations.\n\n## Remediations\n\n- **Do not** use `Integer.toHexString` for converting digest arrays to hexadecimal strings due to the risk of inaccuracies.\n  ```java\n  String hexString = Integer.toHexString(byteValue); // unsafe\n  ```\n- **Do** use `java.util.HexFormat` for accurate hexadecimal conversion in Java 17 and above.\n  ```java\n  MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA-256\");\n  sha256Digest.update(\"hello world\".getBytes(StandardCharsets.UTF_8));\n  byte[] output = sha256Digest.digest();\n\n  HexFormat hex = HexFormat.of();\n  String hexString = hex.formatHex(output);\n  ```\n- **Do** consider using `javax.xml.bind.DatatypeConverter.printHexBinary` for Java versions prior to 17 as an alternative for accurate hex conversion.\n\n## References\n\n- [DatatypeConverter](https://docs.oracle.com/javase/9/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-)","markdown":"## Description\n\nYour application is using `Integer.toHexString` for converting a digest array buffer into a hexadecimal string, which may lead to incorrect representations.\n\n## Remediations\n\n- **Do not** use `Integer.toHexString` for converting digest arrays to hexadecimal strings due to the risk of inaccuracies.\n  ```java\n  String hexString = Integer.toHexString(byteValue); // unsafe\n  ```\n- **Do** use `java.util.HexFormat` for accurate hexadecimal conversion in Java 17 and above.\n  ```java\n  MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA-256\");\n  sha256Digest.update(\"hello world\".getBytes(StandardCharsets.UTF_8));\n  byte[] output = sha256Digest.digest();\n\n  HexFormat hex = HexFormat.of();\n  String hexString = hex.formatHex(output);\n  ```\n- **Do** consider using `javax.xml.bind.DatatypeConverter.printHexBinary` for Java versions prior to 17 as an alternative for accurate hex conversion.\n\n## References\n\n- [DatatypeConverter](https://docs.oracle.com/javase/9/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-)"}},{"id":"java_lang_eval_using_user_input","name":"java_lang_eval_using_user_input","shortDescription":{"text":"Unsanitized user input in 'eval' type function"},"fullDescription":{"text":"Unsanitized user input in 'eval' type function"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing 'eval' or similar functions with unsanitized user input poses a high security risk. This practice can result in command injection attacks, where attackers can execute arbitrary code within your application.\n\n## Remediations\n\n- **Do not** use `eval` or similar functions with user-supplied data. This can open up your application to severe vulnerabilities.\n- **Do** validate and sanitize all user input before using it in your code. Ensure that inputs are checked against a strict set of rules.\n- **Do** use safer alternatives to `eval` for dynamic code execution needs. Consider using functions that do not execute user-supplied data as code.\n\n## References\n\n- [OWASP Code injection explained](https://owasp.org/www-community/attacks/Code_Injection)","markdown":"## Description\n\nUsing 'eval' or similar functions with unsanitized user input poses a high security risk. This practice can result in command injection attacks, where attackers can execute arbitrary code within your application.\n\n## Remediations\n\n- **Do not** use `eval` or similar functions with user-supplied data. This can open up your application to severe vulnerabilities.\n- **Do** validate and sanitize all user input before using it in your code. Ensure that inputs are checked against a strict set of rules.\n- **Do** use safer alternatives to `eval` for dynamic code execution needs. Consider using functions that do not execute user-supplied data as code.\n\n## References\n\n- [OWASP Code injection explained](https://owasp.org/www-community/attacks/Code_Injection)"}},{"id":"java_lang_expression_language_injection","name":"java_lang_expression_language_injection","shortDescription":{"text":"Possible expression language (EL) injection detected"},"fullDescription":{"text":"Possible expression language (EL) injection detected"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nExpression Language (EL) injection vulnerabilities occur when external input is used to construct EL statements without proper validation. This can result in the execution of malicious code.\n\n## Remediations\n\n- **Do** validate all external input or dynamic values before incorporating them into EL statements. This step is crucial to prevent EL injection attacks.\n\n## References\n\n- [OWASP Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection)","markdown":"## Description\n\nExpression Language (EL) injection vulnerabilities occur when external input is used to construct EL statements without proper validation. This can result in the execution of malicious code.\n\n## Remediations\n\n- **Do** validate all external input or dynamic values before incorporating them into EL statements. This step is crucial to prevent EL injection attacks.\n\n## References\n\n- [OWASP Expression Language Injection](https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection)"}},{"id":"javascript_lang_logger_leak","name":"javascript_lang_logger_leak","shortDescription":{"text":"Leakage of information in logger message"},"fullDescription":{"text":"Leakage of information in logger message"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nInformation leakage through logger messages can compromise sensitive data. This vulnerability arises when dynamic data or variables, which may contain sensitive information, are included in log messages.\n\n## Remediations\n\n- **Do not** include sensitive data directly in logger messages. This can lead to the exposure of such data in log files, which might be accessible to unauthorized individuals.\n  ```javascript\n  logger.info(`Results: ${data}`) // unsafe\n  ```\n- **Do** use logging levels appropriately to control the verbosity of log output and minimize the risk of leaking sensitive information in production environments.","markdown":"## Description\n\nInformation leakage through logger messages can compromise sensitive data. This vulnerability arises when dynamic data or variables, which may contain sensitive information, are included in log messages.\n\n## Remediations\n\n- **Do not** include sensitive data directly in logger messages. This can lead to the exposure of such data in log files, which might be accessible to unauthorized individuals.\n  ```javascript\n  logger.info(`Results: ${data}`) // unsafe\n  ```\n- **Do** use logging levels appropriately to control the verbosity of log output and minimize the risk of leaking sensitive information in production environments."}},{"id":"java_lang_hardcoded_database_password","name":"java_lang_hardcoded_database_password","shortDescription":{"text":"Usage of hard-coded database password"},"fullDescription":{"text":"Usage of hard-coded database password"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nHard-coded database passwords pose a significant security risk. Embedding passwords directly in your code can lead to unauthorized database access if the codebase is compromised.\n\n## Remediations\n\n- **Do not** embed database passwords directly in your code. This approach is insecure and makes your database vulnerable to unauthorized access.\n  ```java\n  Connection conn = DriverManager.getConnection(url, \"admin\", \"secret\");\n  ```\n- **Do** use environment variables to store sensitive information such as database passwords. This method keeps credentials out of your codebase and makes them easier to manage securely.\n- **Do** consider implementing a key-management system to securely handle passwords and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)","markdown":"## Description\n\nHard-coded database passwords pose a significant security risk. Embedding passwords directly in your code can lead to unauthorized database access if the codebase is compromised.\n\n## Remediations\n\n- **Do not** embed database passwords directly in your code. This approach is insecure and makes your database vulnerable to unauthorized access.\n  ```java\n  Connection conn = DriverManager.getConnection(url, \"admin\", \"secret\");\n  ```\n- **Do** use environment variables to store sensitive information such as database passwords. This method keeps credentials out of your codebase and makes them easier to manage securely.\n- **Do** consider implementing a key-management system to securely handle passwords and other sensitive information. This approach provides enhanced security measures for managing and accessing credentials.\n\n## References\n\n- [OWASP hardcoded passwords](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)"}},{"id":"java_lang_apache_commons_collection","name":"java_lang_apache_commons_collection","shortDescription":{"text":"Usage of vulnerable Apache Commons Collections InvokeTransformer class"},"fullDescription":{"text":"Usage of vulnerable Apache Commons Collections InvokeTransformer class"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nThe InvokeTransformer class in versions of Apache Commons Collections older than 3.2.2 is susceptible to remote code execution vulnerabilities. This issue arises during the deserialization of data, where malicious actors can execute arbitrary code on the server.\n\n## Remediations\n\n- **Do** upgrade Apache Commons Collections 3 to version 3.2.2 or above to mitigate the vulnerability associated with the InvokeTransformer class.\n  ```java\n  \u003cdependency\u003e\n      \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e\n      \u003cartifactId\u003ecommons-collections4\u003c/artifactId\u003e\n      \u003cversion\u003e3.2.2\u003c/version\u003e\n  \u003c/dependency\u003e\n  ```\n\n## References\n\n- [Apache Commons Collections 3.2.2 Security Report](https://commons.apache.org/proper/commons-collections/security-reports.html)","markdown":"## Description\n\nThe InvokeTransformer class in versions of Apache Commons Collections older than 3.2.2 is susceptible to remote code execution vulnerabilities. This issue arises during the deserialization of data, where malicious actors can execute arbitrary code on the server.\n\n## Remediations\n\n- **Do** upgrade Apache Commons Collections 3 to version 3.2.2 or above to mitigate the vulnerability associated with the InvokeTransformer class.\n  ```java\n  \u003cdependency\u003e\n      \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e\n      \u003cartifactId\u003ecommons-collections4\u003c/artifactId\u003e\n      \u003cversion\u003e3.2.2\u003c/version\u003e\n  \u003c/dependency\u003e\n  ```\n\n## References\n\n- [Apache Commons Collections 3.2.2 Security Report](https://commons.apache.org/proper/commons-collections/security-reports.html)"}},{"id":"javascript_lang_weak_password_encryption_rc4","name":"javascript_lang_weak_password_encryption_rc4","shortDescription":{"text":"Usage of weak encryption algorithm on a password (RC4)"},"fullDescription":{"text":"Usage of weak encryption algorithm on a password (RC4)"},"defaultConfiguration":{"level":"error"},"help":{"text":"## Description\n\nUsing RC4 for encrypting passwords is insecure. RC4 is a weak encryption algorithm that can be easily compromised, leading to potential security risks. Furthermore, using any form of encryption for passwords is not advisable because encryption is designed to be reversible. This means that given enough resources, an attacker could decrypt the passwords and access them in plain text. For securing passwords, hashing is the recommended approach because it is a one-way process that does not allow for the original password to be retrieved.\n\n## Remediations\n\n- **Do not** use RC4 or any encryption algorithm for password storage. Encryption algorithms are not secure enough for password protection and can be reversed to expose plain text passwords.\n- **Do** use a secure hashing algorithm specifically designed for password storage, such as Argon2id. Hashing is a one-way process, making it significantly more secure for storing passwords.\n```javascript\nconst argon2 = require(\"argon2\");\nconst hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)","markdown":"## Description\n\nUsing RC4 for encrypting passwords is insecure. RC4 is a weak encryption algorithm that can be easily compromised, leading to potential security risks. Furthermore, using any form of encryption for passwords is not advisable because encryption is designed to be reversible. This means that given enough resources, an attacker could decrypt the passwords and access them in plain text. For securing passwords, hashing is the recommended approach because it is a one-way process that does not allow for the original password to be retrieved.\n\n## Remediations\n\n- **Do not** use RC4 or any encryption algorithm for password storage. Encryption algorithms are not secure enough for password protection and can be reversed to expose plain text passwords.\n- **Do** use a secure hashing algorithm specifically designed for password storage, such as Argon2id. Hashing is a one-way process, making it significantly more secure for storing passwords.\n```javascript\nconst argon2 = require(\"argon2\");\nconst hash = await argon2.hash(req.params.password, { type: argon2.argon2id })\n```\n\n## References\n\n- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)"}}]}},"results":[{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7.java"},"region":{"startLine":34,"startColumn":3,"endColumn":87,"endLine":34}}}],"partialFingerprints":{"primaryLocationLineHash":"6b34a46b968c1a03a78e00c3e9621b1d_0"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":44,"startColumn":3,"endColumn":96,"endLine":44}}}],"partialFingerprints":{"primaryLocationLineHash":"bc49400ef71025e325502eb0b39e0446_0"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"},"region":{"startLine":61,"startColumn":3,"endColumn":60,"endLine":61}}}],"partialFingerprints":{"primaryLocationLineHash":"2b52a2c88408a50b74deed1418ec8ce8_0"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"},"region":{"startLine":62,"startColumn":3,"endColumn":65,"endLine":62}}}],"partialFingerprints":{"primaryLocationLineHash":"2b52a2c88408a50b74deed1418ec8ce8_1"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"},"region":{"startLine":77,"startColumn":43,"endColumn":68,"endLine":77}}}],"partialFingerprints":{"primaryLocationLineHash":"2b52a2c88408a50b74deed1418ec8ce8_2"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java"},"region":{"startLine":49,"startColumn":3,"endColumn":5,"endLine":51}}}],"partialFingerprints":{"primaryLocationLineHash":"ff2c5119bc983c55deb70067ddacbae7_0"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionAC.java"},"region":{"startLine":32,"startColumn":3,"endColumn":80,"endLine":32}}}],"partialFingerprints":{"primaryLocationLineHash":"5896cc75f2314022d44d508fc651ed1a_0"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionAC.java"},"region":{"startLine":33,"startColumn":3,"endColumn":79,"endLine":33}}}],"partialFingerprints":{"primaryLocationLineHash":"5896cc75f2314022d44d508fc651ed1a_1"}},{"ruleId":"java_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java"},"region":{"startLine":62,"startColumn":3,"endColumn":69,"endLine":63}}}],"partialFingerprints":{"primaryLocationLineHash":"b2f2f1311efb0b2ba849c8dedf16315d_0"}},{"ruleId":"java_lang_jwt_verification_bypass","message":{"text":"Missing signature verification of JWT"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/it/java/org/owasp/webgoat/JWTLessonIntegrationTest.java"},"region":{"startLine":73,"startColumn":19,"endColumn":89,"endLine":73}}}],"partialFingerprints":{"primaryLocationLineHash":"5dba131830c28bd6d0bb02adb4d28bdd_0"}},{"ruleId":"java_lang_jwt_verification_bypass","message":{"text":"Missing signature verification of JWT"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"},"region":{"startLine":107,"startColumn":17,"endColumn":94,"endLine":107}}}],"partialFingerprints":{"primaryLocationLineHash":"b5daa8b430ace1ecc4b686fe0e922ad3_0"}},{"ruleId":"java_lang_jwt_verification_bypass","message":{"text":"Missing signature verification of JWT"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"},"region":{"startLine":137,"startColumn":11,"endColumn":88,"endLine":137}}}],"partialFingerprints":{"primaryLocationLineHash":"b5daa8b430ace1ecc4b686fe0e922ad3_1"}},{"ruleId":"java_lang_jwt_verification_bypass","message":{"text":"Missing signature verification of JWT"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"},"region":{"startLine":155,"startColumn":19,"endColumn":79,"endLine":155}}}],"partialFingerprints":{"primaryLocationLineHash":"c555dffcab4f689b5c69481e38906e78_0"}},{"ruleId":"java_lang_jwt_verification_bypass","message":{"text":"Missing signature verification of JWT"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"},"region":{"startLine":180,"startColumn":19,"endColumn":79,"endLine":180}}}],"partialFingerprints":{"primaryLocationLineHash":"c555dffcab4f689b5c69481e38906e78_1"}},{"ruleId":"java_lang_jwt_verification_bypass","message":{"text":"Missing signature verification of JWT"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"},"region":{"startLine":203,"startColumn":19,"endColumn":79,"endLine":203}}}],"partialFingerprints":{"primaryLocationLineHash":"c555dffcab4f689b5c69481e38906e78_2"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java"},"region":{"startLine":59,"startColumn":11,"endColumn":25,"endLine":64}}}],"partialFingerprints":{"primaryLocationLineHash":"7c1e983748ed4aaeaeb573a01cbc1ac2_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java"},"region":{"startLine":69,"startColumn":31,"endColumn":69,"endLine":69}}}],"partialFingerprints":{"primaryLocationLineHash":"2fb73a3198fd2e190dd8f5c14d98e34d_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java"},"region":{"startLine":88,"startColumn":27,"endColumn":56,"endLine":88}}}],"partialFingerprints":{"primaryLocationLineHash":"3cf8843e1ecebf95e4bdae52c1c3d738_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java"},"region":{"startLine":71,"startColumn":29,"endColumn":58,"endLine":71}}}],"partialFingerprints":{"primaryLocationLineHash":"60c046f0abdfc36644828cd875741ac5_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java"},"region":{"startLine":65,"startColumn":27,"endColumn":56,"endLine":65}}}],"partialFingerprints":{"primaryLocationLineHash":"c2f31f20200ecfb952ab096ddfc7a872_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java"},"region":{"startLine":63,"startColumn":9,"endColumn":39,"endLine":63}}}],"partialFingerprints":{"primaryLocationLineHash":"69fca3af67ffa53ff7b3edcdb9976986_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java"},"region":{"startLine":62,"startColumn":9,"endColumn":39,"endLine":62}}}],"partialFingerprints":{"primaryLocationLineHash":"d6378384d973dcd83bda3400590a0483_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java"},"region":{"startLine":80,"startColumn":9,"endColumn":38,"endLine":80}}}],"partialFingerprints":{"primaryLocationLineHash":"72fa25d52dbef4dc7c0d653710409e25_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java"},"region":{"startLine":67,"startColumn":29,"endColumn":58,"endLine":67}}}],"partialFingerprints":{"primaryLocationLineHash":"9185ad9af1d5b2bfb927d454daf93349_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java"},"region":{"startLine":65,"startColumn":11,"endColumn":90,"endLine":66}}}],"partialFingerprints":{"primaryLocationLineHash":"0c379d6df932c0a8540216d15252d4a5_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java"},"region":{"startLine":78,"startColumn":29,"endColumn":58,"endLine":78}}}],"partialFingerprints":{"primaryLocationLineHash":"c3890749a8c17836c1e9b09a0a3492a0_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java"},"region":{"startLine":158,"startColumn":7,"endColumn":40,"endLine":158}}}],"partialFingerprints":{"primaryLocationLineHash":"c3890749a8c17836c1e9b09a0a3492a0_1"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java"},"region":{"startLine":81,"startColumn":7,"endColumn":40,"endLine":81}}}],"partialFingerprints":{"primaryLocationLineHash":"1d7b1b2791c4cc7f1dc3de354d1ff7d7_0"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java"},"region":{"startLine":111,"startColumn":25,"endColumn":54,"endLine":111}}}],"partialFingerprints":{"primaryLocationLineHash":"1d7b1b2791c4cc7f1dc3de354d1ff7d7_1"}},{"ruleId":"java_lang_sqli","message":{"text":"Unsanitized external input in SQL query"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java"},"region":{"startLine":72,"startColumn":11,"endColumn":28,"endLine":75}}}],"partialFingerprints":{"primaryLocationLineHash":"6cd7c81b9459bc8172f4532c44291af4_0"}},{"ruleId":"javascript_lang_hardcoded_secret","message":{"text":"Usage of hard-coded secret"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/lessons/jwt/js/jwt-refresh.js"},"region":{"startLine":10,"startColumn":43,"endColumn":71,"endLine":10}}}],"partialFingerprints":{"primaryLocationLineHash":"71a4743df32485bdaf8cd6a56712673a_0"}},{"ruleId":"java_lang_path_using_user_input","message":{"text":"Unsanitized user input in file path"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java"},"region":{"startLine":95,"startColumn":11,"endColumn":98,"endLine":95}}}],"partialFingerprints":{"primaryLocationLineHash":"8a9011c464ff4bb186caf41365f8abb2_0"}},{"ruleId":"javascript_lang_dangerous_insert_html","message":{"text":"Unsanitized user input in dynamic HTML insertion (XSS)"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js"},"region":{"startLine":6,"startColumn":5,"endColumn":107,"endLine":6}}}],"partialFingerprints":{"primaryLocationLineHash":"4dad74807f12495a5b511f37121e82b4_0"}},{"ruleId":"javascript_lang_dangerous_insert_html","message":{"text":"Unsanitized user input in dynamic HTML insertion (XSS)"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js"},"region":{"startLine":38,"startColumn":9,"endColumn":32,"endLine":38}}}],"partialFingerprints":{"primaryLocationLineHash":"4dad74807f12495a5b511f37121e82b4_1"}},{"ruleId":"javascript_lang_dangerous_insert_html","message":{"text":"Unsanitized user input in dynamic HTML insertion (XSS)"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/quiz.js"},"region":{"startLine":34,"startColumn":13,"endColumn":68,"endLine":34}}}],"partialFingerprints":{"primaryLocationLineHash":"5d90e0f1b46dd22b62bba409e268d429_0"}},{"ruleId":"java_lang_cookie_missing_http_only","message":{"text":"Missing HTTP Only option in cookie configuration"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignment.java"},"region":{"startLine":86,"startColumn":21,"endColumn":57,"endLine":86}}}],"partialFingerprints":{"primaryLocationLineHash":"c9842b9cc40864732406bb775b3d99f5_0"}},{"ruleId":"java_lang_cookie_missing_http_only","message":{"text":"Missing HTTP Only option in cookie configuration"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"},"region":{"startLine":130,"startColumn":23,"endColumn":56,"endLine":130}}}],"partialFingerprints":{"primaryLocationLineHash":"1b4a406307fa0e3ee2668748da1f938e_0"}},{"ruleId":"java_lang_cookie_missing_http_only","message":{"text":"Missing HTTP Only option in cookie configuration"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"},"region":{"startLine":135,"startColumn":23,"endColumn":53,"endLine":135}}}],"partialFingerprints":{"primaryLocationLineHash":"1b4a406307fa0e3ee2668748da1f938e_1"}},{"ruleId":"java_lang_cookie_missing_http_only","message":{"text":"Missing HTTP Only option in cookie configuration"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java"},"region":{"startLine":79,"startColumn":21,"endColumn":48,"endLine":79}}}],"partialFingerprints":{"primaryLocationLineHash":"b719bb6ca61d83e376f3cbe8beb478c7_0"}},{"ruleId":"java_lang_cookie_missing_http_only","message":{"text":"Missing HTTP Only option in cookie configuration"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java"},"region":{"startLine":95,"startColumn":26,"endColumn":65,"endLine":95}}}],"partialFingerprints":{"primaryLocationLineHash":"b719bb6ca61d83e376f3cbe8beb478c7_1"}},{"ruleId":"java_lang_cookie_missing_secure","message":{"text":"Missing Secure option in cookie configuration"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"},"region":{"startLine":130,"startColumn":23,"endColumn":56,"endLine":130}}}],"partialFingerprints":{"primaryLocationLineHash":"5e32c12ef98c0b5f37a58370fc750d44_0"}},{"ruleId":"java_lang_cookie_missing_secure","message":{"text":"Missing Secure option in cookie configuration"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"},"region":{"startLine":135,"startColumn":23,"endColumn":53,"endLine":135}}}],"partialFingerprints":{"primaryLocationLineHash":"5e32c12ef98c0b5f37a58370fc750d44_1"}},{"ruleId":"java_lang_crlf_injection","message":{"text":"Possible CLRF injection detected"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java"},"region":{"startLine":165,"startColumn":9,"endColumn":51,"endLine":165}}}],"partialFingerprints":{"primaryLocationLineHash":"088c4a74250c4fb9843a0acf82f7514c_0"}},{"ruleId":"java_lang_crlf_injection","message":{"text":"Possible CLRF injection detected"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/webwolf/requests/LandingPage.java"},"region":{"startLine":48,"startColumn":7,"endColumn":69,"endLine":48}}}],"partialFingerprints":{"primaryLocationLineHash":"9a8ce44260f9ad869a6728e5408a3811_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/challenges/challenge1/ImageServlet.java"},"region":{"startLine":17,"startColumn":37,"endColumn":49,"endLine":17}}}],"partialFingerprints":{"primaryLocationLineHash":"46b7138113345f3c1c900b4fe3a6ff27_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java"},"region":{"startLine":14,"startColumn":21,"endColumn":33,"endLine":14}}}],"partialFingerprints":{"primaryLocationLineHash":"e4492b8a57354c1746cb7e20a91758c1_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java"},"region":{"startLine":52,"startColumn":37,"endColumn":49,"endLine":52}}}],"partialFingerprints":{"primaryLocationLineHash":"3dda0d8614e872286fc93f457fbfce04_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":53,"startColumn":31,"endColumn":43,"endLine":53}}}],"partialFingerprints":{"primaryLocationLineHash":"0d91811e3a097b333f2f10fd4b8805aa_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":71,"startColumn":31,"endColumn":43,"endLine":71}}}],"partialFingerprints":{"primaryLocationLineHash":"0d91811e3a097b333f2f10fd4b8805aa_1"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java"},"region":{"startLine":57,"startColumn":25,"endColumn":37,"endLine":57}}}],"partialFingerprints":{"primaryLocationLineHash":"7e16bafa9e52d9d1e4784d20c512eba2_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java"},"region":{"startLine":63,"startColumn":25,"endColumn":37,"endLine":63}}}],"partialFingerprints":{"primaryLocationLineHash":"7e16bafa9e52d9d1e4784d20c512eba2_1"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java"},"region":{"startLine":74,"startColumn":23,"endColumn":35,"endLine":74}}}],"partialFingerprints":{"primaryLocationLineHash":"7e16bafa9e52d9d1e4784d20c512eba2_2"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/hijacksession/cas/HijackSessionAuthenticationProvider.java"},"region":{"startLine":48,"startColumn":28,"endColumn":40,"endLine":48}}}],"partialFingerprints":{"primaryLocationLineHash":"26e323be3fe73304c610b028dc1c4ad8_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"},"region":{"startLine":92,"startColumn":27,"endColumn":65,"endLine":92}}}],"partialFingerprints":{"primaryLocationLineHash":"75af31b31b74f6d2aa96dae7992bcccd_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java"},"region":{"startLine":53,"startColumn":39,"endColumn":51,"endLine":53}}}],"partialFingerprints":{"primaryLocationLineHash":"fab541a87f8da7b9f7bead25c5e9e901_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java"},"region":{"startLine":95,"startColumn":56,"endColumn":82,"endLine":95}}}],"partialFingerprints":{"primaryLocationLineHash":"d3c8abab10832fd4bd993c99170cc166_0"}},{"ruleId":"java_lang_insufficiently_random_values","message":{"text":"Usage of insufficient random value"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/encoders/EncDec.java"},"region":{"startLine":40,"startColumn":38,"endColumn":76,"endLine":40}}}],"partialFingerprints":{"primaryLocationLineHash":"f1750249231287e999b0101fe2605aa9_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java"},"region":{"startLine":103,"startColumn":11,"endColumn":67,"endLine":103}}}],"partialFingerprints":{"primaryLocationLineHash":"b21b4b2304e7da026fb3901c2364c184_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java"},"region":{"startLine":106,"startColumn":11,"endColumn":74,"endLine":106}}}],"partialFingerprints":{"primaryLocationLineHash":"b21b4b2304e7da026fb3901c2364c184_1"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/challenges/challenge1/Assignment1.java"},"region":{"startLine":56,"startColumn":16,"endColumn":34,"endLine":58}}}],"partialFingerprints":{"primaryLocationLineHash":"588de0c49c9913eb0eafddb85548448d_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":90,"startColumn":11,"endColumn":40,"endLine":90}}}],"partialFingerprints":{"primaryLocationLineHash":"3c5ca9433492007fd8e9802574ad2bb6_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":92,"startColumn":18,"endColumn":47,"endLine":92}}}],"partialFingerprints":{"primaryLocationLineHash":"3c5ca9433492007fd8e9802574ad2bb6_1"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/idor/IDORLogin.java"},"region":{"startLine":70,"startColumn":37,"endColumn":93,"endLine":70}}}],"partialFingerprints":{"primaryLocationLineHash":"1d1107defe64d291f2184d988ef78ce5_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/insecurelogin/InsecureLoginTask.java"},"region":{"startLine":36,"startColumn":43,"endColumn":72,"endLine":36}}}],"partialFingerprints":{"primaryLocationLineHash":"ac7efdc79087ab79128c9eaccf132143_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"},"region":{"startLine":77,"startColumn":43,"endColumn":68,"endLine":77}}}],"partialFingerprints":{"primaryLocationLineHash":"a821f85d89c53683d4f3b963a99d141b_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java"},"region":{"startLine":60,"startColumn":37,"endColumn":67,"endLine":60}}}],"partialFingerprints":{"primaryLocationLineHash":"0e7c174df6f1f2c5ca3461953e1f5f91_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACYourHash.java"},"region":{"startLine":55,"startColumn":9,"endColumn":51,"endLine":55}}}],"partialFingerprints":{"primaryLocationLineHash":"a670503a294a26a504778301ffec915a_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACYourHashAdmin.java"},"region":{"startLine":63,"startColumn":9,"endColumn":51,"endLine":63}}}],"partialFingerprints":{"primaryLocationLineHash":"2f0181e51c91e3b76ac4315cf69c7c39_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java"},"region":{"startLine":89,"startColumn":11,"endColumn":45,"endLine":89}}}],"partialFingerprints":{"primaryLocationLineHash":"d5b96026b4b57fc0558644fbda413e78_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java"},"region":{"startLine":91,"startColumn":18,"endColumn":46,"endLine":91}}}],"partialFingerprints":{"primaryLocationLineHash":"d5b96026b4b57fc0558644fbda413e78_1"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/passwordreset/SimpleMailAssignment.java"},"region":{"startLine":68,"startColumn":45,"endColumn":91,"endLine":68}}}],"partialFingerprints":{"primaryLocationLineHash":"a4d5d559e0a175daa69f7d50da226483_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java"},"region":{"startLine":88,"startColumn":12,"endColumn":58,"endLine":88}}}],"partialFingerprints":{"primaryLocationLineHash":"4831d9755e77507980f63a9337371d0d_0"}},{"ruleId":"java_lang_observable_timing","message":{"text":"Observable Timing Discrepancy"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java"},"region":{"startLine":93,"startColumn":36,"endColumn":65,"endLine":93}}}],"partialFingerprints":{"primaryLocationLineHash":"4831d9755e77507980f63a9337371d0d_1"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/container/controller/StartLesson.java"},"region":{"startLine":62,"startColumn":15,"endColumn":53,"endLine":62}}}],"partialFingerprints":{"primaryLocationLineHash":"138eca51132a3fc2a4c965bbf38b83b6_0"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java"},"region":{"startLine":54,"startColumn":7,"endColumn":64,"endLine":54}}}],"partialFingerprints":{"primaryLocationLineHash":"909b90cf5a396fd9c415458a2132bbf9_0"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":59,"startColumn":7,"endColumn":60,"endLine":59}}}],"partialFingerprints":{"primaryLocationLineHash":"43c0522f2b96c3347b2b066551925699_0"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":60,"startColumn":7,"endColumn":61,"endLine":60}}}],"partialFingerprints":{"primaryLocationLineHash":"43c0522f2b96c3347b2b066551925699_1"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":73,"startColumn":7,"endColumn":62,"endLine":73}}}],"partialFingerprints":{"primaryLocationLineHash":"43c0522f2b96c3347b2b066551925699_2"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":74,"startColumn":7,"endColumn":64,"endLine":74}}}],"partialFingerprints":{"primaryLocationLineHash":"43c0522f2b96c3347b2b066551925699_3"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java"},"region":{"startLine":61,"startColumn":7,"endColumn":72,"endLine":61}}}],"partialFingerprints":{"primaryLocationLineHash":"3d696445b3f5752399233dfee7f84a20_0"}},{"ruleId":"java_lang_trust_boundary_violation","message":{"text":"Usage of trusted and untrusted data inside the same data structure"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java"},"region":{"startLine":62,"startColumn":7,"endColumn":60,"endLine":62}}}],"partialFingerprints":{"primaryLocationLineHash":"3d696445b3f5752399233dfee7f84a20_1"}},{"ruleId":"java_lang_weak_hash_md5","message":{"text":"Usage of weak hashing library (MD5)"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java"},"region":{"startLine":56,"startColumn":7,"endColumn":35,"endLine":56}}}],"partialFingerprints":{"primaryLocationLineHash":"07346d0781fad4927e722924fd2c91ac_0"}},{"ruleId":"javascript_lang_dynamic_regex","message":{"text":"Unsanitized dynamic input in regular expression"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/libs/mode-java.js"},"region":{"startLine":573,"startColumn":35,"endColumn":10,"endLine":575}}}],"partialFingerprints":{"primaryLocationLineHash":"ae876a6ed90f02cb8d4e4f702ced276e_0"}},{"ruleId":"javascript_lang_dynamic_regex","message":{"text":"Unsanitized dynamic input in regular expression"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/libs/mode-java.js"},"region":{"startLine":576,"startColumn":34,"endColumn":10,"endLine":578}}}],"partialFingerprints":{"primaryLocationLineHash":"ae876a6ed90f02cb8d4e4f702ced276e_1"}},{"ruleId":"java_lang_information_leakage","message":{"text":"Leakage of sensitive information in exception message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":".mvn/wrapper/MavenWrapperDownloader.java"},"region":{"startLine":92,"startColumn":13,"endColumn":32,"endLine":92}}}],"partialFingerprints":{"primaryLocationLineHash":"349c934959470f0b84817df36e31825d_0"}},{"ruleId":"java_lang_information_leakage","message":{"text":"Leakage of sensitive information in exception message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java"},"region":{"startLine":39,"startColumn":7,"endColumn":26,"endLine":39}}}],"partialFingerprints":{"primaryLocationLineHash":"b85e830c9e0b785c4f9d38dbc50c8194_0"}},{"ruleId":"java_lang_information_leakage","message":{"text":"Leakage of sensitive information in exception message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java"},"region":{"startLine":170,"startColumn":7,"endColumn":26,"endLine":170}}}],"partialFingerprints":{"primaryLocationLineHash":"fe5ac3d26804c2256e401fdcb438e238_0"}},{"ruleId":"java_lang_information_leakage","message":{"text":"Leakage of sensitive information in exception message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java"},"region":{"startLine":71,"startColumn":9,"endColumn":31,"endLine":71}}}],"partialFingerprints":{"primaryLocationLineHash":"75d66c24293f6bdf7bbee7cfe08cc8b7_0"}},{"ruleId":"java_lang_information_leakage","message":{"text":"Leakage of sensitive information in exception message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java"},"region":{"startLine":75,"startColumn":7,"endColumn":26,"endLine":75}}}],"partialFingerprints":{"primaryLocationLineHash":"75d66c24293f6bdf7bbee7cfe08cc8b7_1"}},{"ruleId":"java_lang_information_leakage","message":{"text":"Leakage of sensitive information in exception message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson10b.java"},"region":{"startLine":130,"startColumn":7,"endColumn":34,"endLine":130}}}],"partialFingerprints":{"primaryLocationLineHash":"1193628ff171698fb7f78c11ff41f9fd_0"}},{"ruleId":"java_lang_information_leakage","message":{"text":"Leakage of sensitive information in exception message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask1.java"},"region":{"startLine":62,"startColumn":7,"endColumn":26,"endLine":62}}}],"partialFingerprints":{"primaryLocationLineHash":"48cdf8f26adb24f18c08cc62841e620c_0"}},{"ruleId":"java_lang_log_injection","message":{"text":"Unsanitized user input in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java"},"region":{"startLine":165,"startColumn":9,"endColumn":51,"endLine":165}}}],"partialFingerprints":{"primaryLocationLineHash":"c49e00fd49fc2f36b608d4ca1bdc768c_0"}},{"ruleId":"java_lang_log_injection","message":{"text":"Unsanitized user input in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/webwolf/requests/LandingPage.java"},"region":{"startLine":48,"startColumn":7,"endColumn":69,"endLine":48}}}],"partialFingerprints":{"primaryLocationLineHash":"1d43af251f44ed96ad166572be5f9e60_0"}},{"ruleId":"java_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java"},"region":{"startLine":56,"startColumn":7,"endColumn":33,"endLine":56}}}],"partialFingerprints":{"primaryLocationLineHash":"1d3a056b7712bba546814b422308d511_0"}},{"ruleId":"java_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java"},"region":{"startLine":69,"startColumn":11,"endColumn":25,"endLine":69}}}],"partialFingerprints":{"primaryLocationLineHash":"1d3a056b7712bba546814b422308d511_1"}},{"ruleId":"java_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java"},"region":{"startLine":60,"startColumn":9,"endColumn":62,"endLine":60}}}],"partialFingerprints":{"primaryLocationLineHash":"feaf1f6c813cca41c2765ea512013dae_0"}},{"ruleId":"java_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java"},"region":{"startLine":49,"startColumn":5,"endColumn":23,"endLine":49}}}],"partialFingerprints":{"primaryLocationLineHash":"b559b3a6cbe0333786ab796014e73487_0"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/lessons/challenges/js/challenge8.js"},"region":{"startLine":12,"startColumn":13,"endColumn":36,"endLine":12}}}],"partialFingerprints":{"primaryLocationLineHash":"3ffc04af3b6557106ec443557ca34b0e_0"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/lessons/challenges/js/challenge8.js"},"region":{"startLine":15,"startColumn":17,"endColumn":37,"endLine":15}}}],"partialFingerprints":{"primaryLocationLineHash":"3ffc04af3b6557106ec443557ca34b0e_1"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/goatApp/controller/LessonController.js"},"region":{"startLine":124,"startColumn":17,"endColumn":39,"endLine":124}}}],"partialFingerprints":{"primaryLocationLineHash":"b0b1918d8b185e497b904ec23e370202_0"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/goatApp/view/GoatRouter.js"},"region":{"startLine":77,"startColumn":25,"endColumn":80,"endLine":77}}}],"partialFingerprints":{"primaryLocationLineHash":"fe1449242c3c8c6769635b58ebf72844_0"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/goatApp/view/LessonContentView.js"},"region":{"startLine":159,"startColumn":17,"endColumn":36,"endLine":159}}}],"partialFingerprints":{"primaryLocationLineHash":"a707ca99e1274ce8cce08d97340c2389_0"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/goatApp/view/LessonContentView.js"},"region":{"startLine":163,"startColumn":17,"endColumn":33,"endLine":163}}}],"partialFingerprints":{"primaryLocationLineHash":"a707ca99e1274ce8cce08d97340c2389_1"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webgoat/static/js/goatApp/view/LessonContentView.js"},"region":{"startLine":164,"startColumn":17,"endColumn":33,"endLine":164}}}],"partialFingerprints":{"primaryLocationLineHash":"a707ca99e1274ce8cce08d97340c2389_2"}},{"ruleId":"javascript_lang_logger_leak","message":{"text":"Leakage of information in logger message"},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main/resources/webwolf/static/js/jwt.js"},"region":{"startLine":50,"startColumn":9,"endColumn":30,"endLine":50}}}],"partialFingerprints":{"primaryLocationLineHash":"7bb603f5daf18a260185876fc4a112dd_0"}}]}]}
